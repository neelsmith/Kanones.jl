var documenterSearchIndex = {"docs":
[{"location":"parsing/#Compiling-and-parsing","page":"Compiling and parsing","title":"Compiling and parsing","text":"","category":"section"},{"location":"parsing/","page":"Compiling and parsing","title":"Compiling and parsing","text":"Build a parser with the buildparser function.","category":"page"},{"location":"parsing/","page":"Compiling and parsing","title":"Compiling and parsing","text":"See Managing Kanones datasets","category":"page"},{"location":"parsing/","page":"Compiling and parsing","title":"Compiling and parsing","text":"repo = pwd() |> dirname |> dirname  |> dirname\ntarget = tempdir() * \"/demoparser2/\"\nif isdir(target)\n    rm(target, force=true, recursive=true)\n    mkdir(target)\nelse \n    mkdir(target)\nend","category":"page"},{"location":"parsing/","page":"Compiling and parsing","title":"Compiling and parsing","text":"using Kanones, Kanones.FstBuilder\n\ncore_inflection = joinpath(repo, \"datasets\", \"core-infl\")\ncore_vocab = joinpath(repo, \"datasets\", \"core-vocab\")\nkd = dataset([core_inflection, core_vocab])\n\nfstsrc = joinpath(repo, \"fst\")\nparser = buildparser(kd, fstsrc, target)\nbasename(parser.sfstpath)","category":"page"},{"location":"stemtypes/nouns/nounstems/#Noun-stems","page":"Nouns","title":"Noun stems","text":"","category":"section"},{"location":"stemtypes/nouns/nounstems/","page":"Nouns","title":"Nouns","text":"The automatically generated paradigms on this page illustrate nouns accent belonging to various stem types, and with various patterns of persistent accent.  They belong to the dataset defined in the datasets/core-infl directory of the Kanones github repository.","category":"page"},{"location":"stemtypes/nouns/nounstems/","page":"Nouns","title":"Nouns","text":"In the tables below, the nouns are labelled with the Kanones stem type they belong to.","category":"page"},{"location":"stemtypes/nouns/nounstems/#First-declension-types","page":"Nouns","title":"First declension types","text":"","category":"section"},{"location":"stemtypes/nouns/nounstems/","page":"Nouns","title":"Nouns","text":"Literary Greek orthography:","category":"page"},{"location":"stemtypes/nouns/nounstems/","page":"Nouns","title":"Nouns","text":"using Kanones, CitableParserBuilder, Markdown\n\nβουλη = LexemeUrn(\"lsj.n20600\")\nγνωμη = LexemeUrn(\"lsj.n22502\")\nθεραπαινα = LexemeUrn(\"lsj.n48369\")\nοικια = LexemeUrn(\"lsj.n72287\")\nnouns = [γνωμη, βουλη,οικια,θεραπαινα]\n\nrepo = pwd() |> dirname |> dirname  |> dirname |> dirname\nds = dataset(repo * \"/datasets/core-infl/\")\nMarkdown.parse(mddeclension(nouns, ds))","category":"page"},{"location":"stemtypes/nouns/nounstems/","page":"Nouns","title":"Nouns","text":"Attic orthography:","category":"page"},{"location":"stemtypes/nouns/nounstems/","page":"Nouns","title":"Nouns","text":"using Kanones, CitableParserBuilder, Markdown, AtticGreek\nbole = LexemeUrn(\"lsj.n20600\")\nrepo = pwd() |> dirname |> dirname  |> dirname |> dirname\nattic = dataset([repo * \"/datasets/attic/\"]; ortho=atticGreek())\nMarkdown.parse(mddeclension([bole], attic))","category":"page"},{"location":"stemtypes/nouns/nounstems/#Second-declension-types","page":"Nouns","title":"Second declension types","text":"","category":"section"},{"location":"stemtypes/nouns/nounstems/","page":"Nouns","title":"Nouns","text":"Literary Greek orthography:","category":"page"},{"location":"stemtypes/nouns/nounstems/","page":"Nouns","title":"Nouns","text":"repo = pwd() |> dirname |> dirname  |> dirname |> dirname\nusing Kanones, CitableParserBuilder, Markdown\nkd = dataset(repo * \"/datasets/core-infl/\")\n\nανθρωπος = LexemeUrn(\"lsj.n8909\")\nδωρον = LexemeUrn(\"lsj.n29828\")\n\nnouns = [ανθρωπος,δωρον ]\nMarkdown.parse(mddeclension(nouns, kd))","category":"page"},{"location":"stemtypes/nouns/nounstems/","page":"Nouns","title":"Nouns","text":"Attic Greek orthography:","category":"page"},{"location":"stemtypes/nouns/nounstems/","page":"Nouns","title":"Nouns","text":"repo = pwd() |> dirname |> dirname  |> dirname |> dirname\nusing Kanones, CitableParserBuilder, Markdown, AtticGreek\nattic = dataset(repo * \"/datasets/attic/\"; ortho=atticGreek())\n\nανθρωπος = LexemeUrn(\"lsj.n8909\")\n\nnouns = [ανθρωπος]\nMarkdown.parse(mddeclension(nouns, attic))","category":"page"},{"location":"stemtypes/nouns/nounstems/#Third-declension-types","page":"Nouns","title":"Third declension types","text":"","category":"section"},{"location":"stemtypes/nouns/nounstems/","page":"Nouns","title":"Nouns","text":"Literary Greek orthography:","category":"page"},{"location":"stemtypes/nouns/nounstems/","page":"Nouns","title":"Nouns","text":"repo = pwd() |> dirname |> dirname  |> dirname |> dirname\nusing Kanones, CitableParserBuilder, Markdown\nkd = dataset(repo * \"/datasets/core-infl/\")\n\nπολις = LexemeUrn(\"lsj.n84494\")\n\nnouns = [πολις]\n\nMarkdown.parse(mddeclension(nouns, kd))","category":"page"},{"location":"stemtypes/#Illustrative-paradigms","page":"Contents","title":"Illustrative paradigms","text":"","category":"section"},{"location":"stemtypes/","page":"Contents","title":"Contents","text":"The following pages illustrate various stem types Kanones defines for each analytical type.  They include automatically generated declensions and synopses for each stem type in the dataset defined in the datasets/core-infl subdirectory of the Kanones github repository.","category":"page"},{"location":"stemtypes/","page":"Contents","title":"Contents","text":"Add table of contents for paradigms here.","category":"page"},{"location":"prereqs/#Prerequisites","page":"Prerequisites","title":"Prerequisites","text":"","category":"section"},{"location":"prereqs/","page":"Prerequisites","title":"Prerequisites","text":"a POSIX-like environment with sh, echo and make\nthe Stuttgart FST toolkit","category":"page"},{"location":"fst/#Internals-of-building-and-using-a-finite-state-transducer","page":"FST","title":"Internals of building and using a finite state transducer","text":"","category":"section"},{"location":"fst/","page":"FST","title":"FST","text":"note: Note\nIn order to use Kanones.jl, it is not necessary to understand the internal logic that the FST follows in parsing morphology","category":"page"},{"location":"fst/","page":"FST","title":"FST","text":"The final parsing transducer is actually created by a chain of smaller transducers. In broad outline, they do the following:","category":"page"},{"location":"fst/","page":"FST","title":"FST","text":"combine all lexical entries (\"stems\") with all inflectional rules (that is, generate the cross product of stems and rules)\npass to a transducer that accepts only pairings of stems and rules belonging to the same stemtype (defined in symbols/stemtypes.fst)\ncategorize all symbols as either \"surface\" symbols, or \"analytical\" symbols, and allow only one category to pass through","category":"page"},{"location":"fst/","page":"FST","title":"FST","text":"The transducers that do this work are organized in the following directories:","category":"page"},{"location":"fst/#FST-symbols","page":"FST","title":"FST symbols","text":"","category":"section"},{"location":"fst/","page":"FST","title":"FST","text":"A finite state transducer transforms symbols between a generated, or surface, form and an analysis.","category":"page"},{"location":"fst/","page":"FST","title":"FST","text":"The vocabulary of symbols  is defined in the file symbols.fst located in the root directory of the build. This file in turn uses include statements to draw together symbol definitions from five files in the adjacent symbols directory. Together, these define the complete set of symbols recognized by the FST, so any transducer has access to the full symbol set by including symbols.fst.","category":"page"},{"location":"fst/#Organization-of-definitions-in-the-symbols-directory","page":"FST","title":"Organization of definitions in the symbols directory","text":"","category":"section"},{"location":"fst/","page":"FST","title":"FST","text":"Within the symbols directory, definitions are organized as follows:","category":"page"},{"location":"fst/","page":"FST","title":"FST","text":"alphabet.fst: defines the symbols used to encode text strings in this orthography.  This is generated automatically from an implementation of GreekOrthograpy.\nmarkup.fst: special symbols for separating stem from inflectional component in the morphological database, and marking the beginning and ends of URN values in the data.\nmorphsymbols.fst: defines symbols for analytical values (such as “gender”, “case” and “number” for nouns).\nphonology.fst: defines all legal symbols in the FST other than the morphological categories defined in stemtypes.fst\nstemtypes.fst: defines symbols in the FST for morphological categories for stems.","category":"page"},{"location":"bg/#Background","page":"Background","title":"Background","text":"","category":"section"},{"location":"bg/","page":"Background","title":"Background","text":"morphological analysis is most typically implement with finite state transducers (FSTs)\nthe morphology of accented Greek is not reversible with FSTs due to the complex interactions of morphology and mutable accent\nKanones addresses this by using the \"analysis by synthesis\" algorithm first developed by Kosman and Smith in the mid-1980s","category":"page"},{"location":"bg/#Analysis-by-synthesis","page":"Background","title":"Analysis by synthesis","text":"","category":"section"},{"location":"bg/","page":"Background","title":"Background","text":"the morphology of Greek can be analyzed with FSTs if accent is not considered\naccent can be algorithmically added to a lexical token if the morphology is already known","category":"page"},{"location":"bg/","page":"Background","title":"Background","text":"Consequenlty, to analyze a token,  the approach Kanones takes is:","category":"page"},{"location":"bg/","page":"Background","title":"Background","text":"generate a normalized accented form:\ndrop accents added from enclitics\nconvert barytone accents to oxytone\ngenerate a form with all accents stripped\nanalyze the accent-free form using a FST.  The result is an Array of 0 or more analyses that are considered hypotheses.\nFor each hypothesis, add the appropriate accent to the unaccented string, and compare the result to the normalized accented form created in step 1.  If they match, the hypothetical analysis is valid.","category":"page"},{"location":"stemtypes/nouns/irregulars/#Irregular-nouns","page":"Irregular nouns","title":"Irregular nouns","text":"","category":"section"},{"location":"stemtypes/nouns/irregulars/","page":"Irregular nouns","title":"Irregular nouns","text":"Irregular nouns do not have a stem type.  Irregular noun forms can be individually cataloged in the irregular-stems/nouns directory of your dataset's files.","category":"page"},{"location":"analyses/#Work-with-morphological-analyses","page":"Working with analytical data","title":"Work with morphological analyses","text":"","category":"section"},{"location":"analyses/","page":"Working with analytical data","title":"Working with analytical data","text":"Kanones supports converting the output of an SFST  parser built with Kanones to an object model. \nKanones offers functions for working with analyses.","category":"page"},{"location":"analyses/#An-example","page":"Working with analytical data","title":"An example","text":"","category":"section"},{"location":"analyses/#Parse-a-token","page":"Working with analytical data","title":"Parse a token","text":"","category":"section"},{"location":"analyses/","page":"Working with analytical data","title":"Working with analytical data","text":"using Kanones\nusing Kanones.FstBuilder\nusing CitableParserBuilder\nreporoot = pwd() |> dirname |> dirname |> dirname\ntarget = reporoot * \"/parsers/demo/\"\ndatadirectory = reporoot * \"/datasets/core-infl/\"\nkd = dataset([datadirectory])\nfstsrc = reporoot *  \"/fst/\"\nparser = buildparser(kd, fstsrc, target)","category":"page"},{"location":"analyses/","page":"Working with analytical data","title":"Working with analytical data","text":"Build a parser, as we did in the example on the previous page.","category":"page"},{"location":"analyses/","page":"Working with analytical data","title":"Working with analytical data","text":"basename(parser.sfstpath)","category":"page"},{"location":"analyses/","page":"Working with analytical data","title":"Working with analytical data","text":"Parsing a token returns a (possibly empty) Vector of analyses.","category":"page"},{"location":"analyses/","page":"Working with analytical data","title":"Working with analytical data","text":"analyses = parsetoken(\"κελεύσει\", parser)","category":"page"},{"location":"analyses/#Analyses","page":"Working with analytical data","title":"Analyses","text":"","category":"section"},{"location":"analyses/","page":"Working with analytical data","title":"Working with analytical data","text":"Each analysis has a form of the token stripped of accents, plus four objects with special types of Cite2URNs","category":"page"},{"location":"analyses/","page":"Working with analytical data","title":"Working with analytical data","text":"a1 = analyses[1]\na1.token","category":"page"},{"location":"analyses/","page":"Working with analytical data","title":"Working with analytical data","text":"The two most important URNs are the lexeme and the form.","category":"page"},{"location":"analyses/","page":"Working with analytical data","title":"Working with analytical data","text":"a1.lexeme","category":"page"},{"location":"analyses/","page":"Working with analytical data","title":"Working with analytical data","text":"a1.form","category":"page"},{"location":"analyses/","page":"Working with analytical data","title":"Working with analytical data","text":"You can use the labelform function to get a human-readable label for a form.","category":"page"},{"location":"analyses/","page":"Working with analytical data","title":"Working with analytical data","text":"Kanones.labelform(a1.form.objectid)","category":"page"},{"location":"analyses/#Working-with-analyses","page":"Working with analytical data","title":"Working with analyses","text":"","category":"section"},{"location":"analyses/","page":"Working with analytical data","title":"Working with analytical data","text":"Get a morphform for the analysis.  You can give morphform just about anything you can think of (Cite2Urn, FormUrn, string, for example).  Here, we'll just get it directly from the Analysis.","category":"page"},{"location":"analyses/","page":"Working with analytical data","title":"Working with analytical data","text":"mform = Kanones.morphform(a1)","category":"page"},{"location":"analyses/","page":"Working with analytical data","title":"Working with analytical data","text":"We can check the type of form, and get appropriate information for that type.","category":"page"},{"location":"analyses/","page":"Working with analytical data","title":"Working with analytical data","text":"tensedata = if isa(mform, GMFFiniteVerb)\n        (mform.vtense)\nelse\n        nothing\nend\ntensedata","category":"page"},{"location":"analyses/","page":"Working with analytical data","title":"Working with analytical data","text":"analyses2 = parsetoken(\"δωρα\", parser)\na2 = analyses2[1]\nform2 = Kanones.morphform(a2)\ngenderdata = if isa(form2, GMFNoun)\n        (form2.ngender)\nelse\n        nothing\nend\ngenderdata","category":"page"},{"location":"analyses/#URNs","page":"Working with analytical data","title":"URNs","text":"","category":"section"},{"location":"analyses/","page":"Working with analytical data","title":"Working with analytical data","text":"FormUrns and LexemeUrns are both subtypes of the CitableParserBuilder's AbbreviatedUrn type. You can expand any AbbreviatedUrn using a diction mapping collection abbreviations to full Cite2Urns for the collection.","category":"page"},{"location":"analyses/","page":"Working with analytical data","title":"Working with analytical data","text":"using CitableParserBuilder\nregistry = Dict(\n        \"morphforms\" => \"urn:cite2:kanones:morphforms.v1:\"\n)\nexpanded = expand(a1.form, registry)","category":"page"},{"location":"analyses/","page":"Working with analytical data","title":"Working with analytical data","text":"","category":"page"},{"location":"implementation/units/#Programmer's-notes:-unit-tests","page":"Unit tests","title":"Programmer's notes: unit tests","text":"","category":"section"},{"location":"implementation/units/","page":"Unit tests","title":"Unit tests","text":"For each analytical type, there is a subdirectory of the tests directory with unit tests for the following:","category":"page"},{"location":"implementation/units/","page":"Unit tests","title":"Unit tests","text":"read delimited-text data into object model: test_TYPEdata.jl\nwrite SFST source files for rules and stems: test_TYPEfst.jl\nparse morphological forms to/from FST format: test_TYPEformatting.jl\nparse strings in Analysis objects:  test_TYPEanalysis.jl\nimplement CitableTrait for stems: test_TYPEstems.jl\nimplement CitableTrait for rules: test_TYPErules.jl\ntest forward-generating forms: test_TYPEgenerate.jl","category":"page"},{"location":"implementation/units/","page":"Unit tests","title":"Unit tests","text":"For analytical types that have both regular and irregular forms, unit tests should test each, since their processing pipelines differ.","category":"page"},{"location":"datasets/#Managing-Kanones-datasets","page":"Managing Kanones datasets","title":"Managing Kanones datasets","text":"","category":"section"},{"location":"datasets/","page":"Managing Kanones datasets","title":"Managing Kanones datasets","text":"You manage rules and stems in delimited-text files\nKanones has a required directory structure for data files","category":"page"},{"location":"datasets/","page":"Managing Kanones datasets","title":"Managing Kanones datasets","text":"See the reference section for information on predefined stem types.","category":"page"},{"location":"datasets/#Directory-organization","page":"Managing Kanones datasets","title":"Directory organization","text":"","category":"section"},{"location":"datasets/","page":"Managing Kanones datasets","title":"Managing Kanones datasets","text":"Kanones checks for .cex files in the following subdirectories of a data source:","category":"page"},{"location":"datasets/","page":"Managing Kanones datasets","title":"Managing Kanones datasets","text":"├── irregular-stems\n│   ├── adjectives\n│   ├── adverbs\n│   ├── finiteverbs\n│   ├── infinitives\n│   ├── nouns\n│   ├── participles\n│   └── pronouns\n├── rules-tables\n│   ├── adjectives\n│   ├── adverbs\n│   ├── finiteverbs\n│   ├── infinitives\n│   ├── nouns\n│   ├── participles\n│   └── uninflected\n├── stems-tables\n│   ├── adjectives\n│   ├── nouns\n│   ├── uninflected\n│   ├── verbs-compound\n│   └── verbs-simplex\n└── urnregistry\n    ├── lexemes\n    ├── rules\n    └── stems","category":"page"},{"location":"datasets/#Loading-a-dataset","page":"Managing Kanones datasets","title":"Loading a dataset","text":"","category":"section"},{"location":"datasets/","page":"Managing Kanones datasets","title":"Managing Kanones datasets","text":"Use the dataset function to create a Kanones.Dataset.","category":"page"},{"location":"datasets/","page":"Managing Kanones datasets","title":"Managing Kanones datasets","text":"Pass in a list of full paths to one or more directories laid out according to Kanones conventions, and optionally an orthography.  The default orthogrpahy is LiteraryGreekOthography.","category":"page"},{"location":"datasets/","page":"Managing Kanones datasets","title":"Managing Kanones datasets","text":"repo = pwd() |> dirname |> dirname  |> dirname\n","category":"page"},{"location":"datasets/","page":"Managing Kanones datasets","title":"Managing Kanones datasets","text":"src1 = joinpath(repo, \"datasets\", \"core-infl\")\nsrc2 = joinpath(repo, \"datasets\", \"core-vocab\")\ndatasrcs = [src1, src2]\n\nusing Kanones\nkdata = dataset(datasrcs)\ntypeof(kdata)","category":"page"},{"location":"stemtypes/uninflected/#Uninflected-forms","page":"Uninflected types","title":"Uninflected forms","text":"","category":"section"},{"location":"stemtypes/uninflected/","page":"Uninflected types","title":"Uninflected types","text":"have a \"part of speech\" type","category":"page"},{"location":"apis/apis/#Julia-language-API-documentation","page":"Julia API documentation","title":"Julia language API documentation","text":"","category":"section"},{"location":"apis/apis/","page":"Julia API documentation","title":"Julia API documentation","text":"Pages = [\"apis.md\"]\nDepth = 3","category":"page"},{"location":"apis/apis/#Morphology","page":"Julia API documentation","title":"Morphology","text":"","category":"section"},{"location":"apis/apis/#Structures","page":"Julia API documentation","title":"Structures","text":"","category":"section"},{"location":"apis/apis/","page":"Julia API documentation","title":"Julia API documentation","text":"GreekMorphologicalForm\nKanones.GMFUninflected\nKanones.GMFNoun\nKanones.GMFFiniteVerb","category":"page"},{"location":"apis/apis/#Kanones.GreekMorphologicalForm","page":"Julia API documentation","title":"Kanones.GreekMorphologicalForm","text":"Abstract type of a morphological form in Kanones.\n\n\n\n\n\n","category":"type"},{"location":"apis/apis/#Kanones.GMFUninflected","page":"Julia API documentation","title":"Kanones.GMFUninflected","text":"Uninflected forms have a single property: the \"part of speech\".\n\n\n\n\n\n","category":"type"},{"location":"apis/apis/#Kanones.GMFNoun","page":"Julia API documentation","title":"Kanones.GMFNoun","text":"Nouns have gender, case and number.\n\n\n\n\n\n","category":"type"},{"location":"apis/apis/#Kanones.GMFFiniteVerb","page":"Julia API documentation","title":"Kanones.GMFFiniteVerb","text":"Finite verbs have person, number, tense, mood and voice.\n\n\n\n\n\n","category":"type"},{"location":"apis/apis/#Functions","page":"Julia API documentation","title":"Functions","text":"","category":"section"},{"location":"apis/apis/","page":"Julia API documentation","title":"Julia API documentation","text":"Kanones.urn\nKanones.cex\nKanones.morphform\nKanones.ruleurn\nKanones.formscex\nKanones.formurn\nKanones.pospairs\nKanones.uninflectedpairs\nKanones.casepairs\nKanones.personpairs\nKanones.numberpairs\nKanones.voicepairs\nKanones.tensepairs\nKanones.moodpairs\nKanones.valuedict\nKanones.labeldict\nKanones.labelform\nKanones.gmfNoun\nKanones.nounscex\nKanones.gmfUninflected\n\nKanones.uninflectedcex\nKanones.finiteverbform\n","category":"page"},{"location":"apis/apis/#CitableBase.urn","page":"Julia API documentation","title":"CitableBase.urn","text":"Delegate to specific functions based on  type's citable trait value.\n\nurn(x)\n\n\n\n\n\n\nIt is an error to invoke the urn function on material that is not citable.\n\nurn(_, x)\n\n\n\n\n\n\nCitable text content should implement urn.\n\nurn(_, txt)\n\n\n\n\n\n\nCitable content should implement cex.\n\nurn(_, obj)\n\n\n\n\n\n\nURN identifyiing psg.\n\nurn(psg)\n\n\nRequired function for Citable abstraction.\n\n\n\n\n\nURN identifyiing doc.\n\nurn(doc)\n\n\nRequired function for Citable abstraction.\n\n\n\n\n\nImplement urn function required by Citable interface  for CatalogedText.\n\nurn(cataloged)\n\n\n\n\n\n\nUnique identifier for AnalyzedToken (required for Citable interface).\n\nurn(at)\n\n\n\n\n\n\nIdentifying URN for a GreekLexeme.  If no registry is included, use abbreviated URN; otherwise, expand to full Cite2Urn.\n\n@(SIGNATURES) Required for CitableTrait.\n\n\n\n\n\nConvert a GreekMorphologicalForm to a Cite2Urn.\n\nurn(mf)\n\n\nAll subclasses of GreekMorphologicalForm should implement this specifically for their subclass.\n\n\n\n\n\nCompose a Cite2Urn for a GMFFiniteVerb.\n\nurn(verb)\n\n\n\n\n\n\nIdentifying URN for a VerbStem.  If no registry is included, use abbreviated URN; otherwise, expand to full Cite2Urn.\n\n@(SIGNATURES) Required for CitableTrait.\n\n\n\n\n\nIdentifying URN for a FiniteVerbRule.  If no registry is included, use abbreviated URN; otherwise, expand to full Cite2Urn.\n\n@(SIGNATURES) Required for CitableTrait.\n\n\n\n\n\nCompose a Cite2Urn for an GMFInfinitive.\n\nurn(inf)\n\n\n\n\n\n\nIdentifying URN for an IrregularNounStem.  If no registry is included, use abbreviated URN; otherwise, expand to full Cite2Urn.\n\n@(SIGNATURES) Required for CitableTrait.\n\n\n\n\n\nIdentifying URN for an InfinitiveRule.  If no registry is included, use abbreviated URN; otherwise, expand to full Cite2Urn.\n\n@(SIGNATURES) Required for CitableTrait.\n\n\n\n\n\nCompose a Cite2Urn for a GMFParticiple.\n\nurn(ptcpl)\n\n\n\n\n\n\nIdentifying URN for a ParticipleRule.  If no registry is included, use abbreviated URN; otherwise, expand to full Cite2Urn.\n\n@(SIGNATURES) Required for CitableTrait.\n\n\n\n\n\nCompose a Cite2Urn for a GMFVerbalAdjective.\n\nurn(vadj)\n\n\n\n\n\n\nIdentifying URN for a VerbalAdjectiveRule.  If no registry is included, use abbreviated URN; otherwise, expand to full Cite2Urn.\n\n@(SIGNATURES) Required for CitableTrait.\n\n\n\n\n\nCompose a Cite2Urn for a GMFNoun.\n\nurn(noun)\n\n\n\n\n\n\nIdentifying URN for a NounStem.  If no registry is included, use abbreviated URN; otherwise, expand to full Cite2Urn.\n\n@(SIGNATURES) Required for CitableTrait.\n\n\n\n\n\nIdentifying URN for an IrregularNounStem.  If no registry is included, use abbreviated URN; otherwise, expand to full Cite2Urn.\n\n@(SIGNATURES) Required for CitableTrait.\n\n\n\n\n\nIdentifying URN for a NounRule.  If no registry is included, use abbreviated URN; otherwise, expand to full Cite2Urn.\n\n@(SIGNATURES) Required for CitableTrait.\n\n\n\n\n\nCompose a Cite2Urn for an GMFAdjective.\n\nurn(adj)\n\n\n\n\n\n\nIdentifying URN for an AdjectiveRule.  If no registry is included, use abbreviated URN; otherwise, expand to full Cite2Urn.\n\n@(SIGNATURES) Required for CitableTrait.\n\n\n\n\n\nIdentifying URN for an AdjectiveStem.  If no registry is included, use abbreviated URN; otherwise, expand to full Cite2Urn.\n\n@(SIGNATURES) Required for CitableTrait.\n\n\n\n\n\nIdentifying URN for an IrregularAdjectiveStem.  If no registry is included, use abbreviated URN; otherwise, expand to full Cite2Urn.\n\n@(SIGNATURES) Required for CitableTrait.\n\n\n\n\n\nCompose a Cite2Urn for a GMFPronoun.\n\nurn(pronoun)\n\n\n\n\n\n\nIdentifying URN for a PronounStem.  If no registry is included, use abbreviated URN; otherwise, expand to full Cite2Urn.\n\n@(SIGNATURES) Required for CitableTrait.\n\n\n\n\n\nIdentifying URN for a PronounRule.  If no registry is included, use abbreviated URN; otherwise, expand to full Cite2Urn.\n\n@(SIGNATURES) Required for CitableTrait.\n\n\n\n\n\nCompose URN for an GMFUninflected.\n\nurn(uform)\n\n\nRequired by CitableTrait.\n\n\n\n\n\nIdentifying URN for a NounStem.  If no registry is included, use abbreviated URN; otherwise, expand to full Cite2Urn.\n\n@(SIGNATURES) Required for CitableTrait.\n\n\n\n\n\nIdentifying URN for a UninflectedRule.  If no registry is included, use abbreviated URN; otherwise, expand to full Cite2Urn.\n\n@(SIGNATURES) Required for CitableTrait.\n\n\n\n\n\n","category":"function"},{"location":"apis/apis/#CitableBase.cex","page":"Julia API documentation","title":"CitableBase.cex","text":"Delegate to specific functions based on  type's citable trait value.\n\n\n\n\n\nIt is an error to invoke the cex function on material that is not citable.\n\ncex(, x; delimiter)\n\n\n\n\n\n\nCitable text content should implement cex.\n\ncex(, txt; delimiter)\n\n\n\n\n\n\nCitable content should implement cex.\n\ncex(, obj; delimiter)\n\n\n\n\n\n\nFormat a CitablePassage as a delimited-text string.\n\ncex(psg; delimiter)\n\n\nRequired function for Citable abstraction.\n\n\n\n\n\nFormat a CitableDocument as a CEX ctsdata block.\n\ncex(doc; delimiter)\n\n\nRequired function for Citable abstraction.\n\n\n\n\n\nCompose a delimited-text string for a corpus.\n\ncex(c; delimiter)\n\n\n\n\n\n\nImplement cex function required by Citable interface  for CatalogedText.\n\ncex(cataloged; delimiter)\n\n\n\n\n\n\nSerialize an AnalyzedToken as delimited text (required for Citable interface).\n\ncex(at; delimiter)\n\n\nUses abbreviated URNs.   These can be expanded to full CITE2 URNs when read back with a URN registry, or the delimited function can be used with a URN registry to write full CITE2 URNs.\n\n\n\n\n\nCompose CEX text for a GreekLexeme. If registry is nothing, use abbreivated URN; otherwise, expand identifier to full Cite2Urn.\n\n@(SIGNATURES) Required for CitableTrait.\n\n\n\n\n\nConvert a GreekMorphologicalForm form to a delimited-text string. \n\nAll subclasses of GreekMorphologicalForm should implement this specifically for their subclass.\n\n\n\n\n\nCompose CEX text for a VerbStem. If registry is nothing, use abbreivated URN; otherwise, expand identifier to full Cite2Urn.\n\n@(SIGNATURES) Required for CitableTrait.\n\n\n\n\n\nCompose CEX text for a FiniteVerbRule. If registry is nothing, use abbreivated URN; otherwise, expand identifier to full Cite2Urn.\n\n@(SIGNATURES) Required for CitableTrait.\n\n\n\n\n\nCompose CEX text for an IrregularInfinitiveStem. If registry is nothing, use abbreivated URN; otherwise, expand identifier to full Cite2Urn.\n\n@(SIGNATURES) Required for CitableTrait.\n\n\n\n\n\nCompose CEX text for a InfinitiveRule. If registry is nothing, use abbreivated URN; otherwise, expand identifier to full Cite2Urn.\n\n@(SIGNATURES) Required for CitableTrait.\n\n\n\n\n\nCompose CEX text for a VerbalAdjectiveRule. If registry is nothing, use abbreivated URN; otherwise, expand identifier to full Cite2Urn.\n\n@(SIGNATURES) Required for CitableTrait.\n\n\n\n\n\nCompose CEX text for a VerbalAdjectiveRule. If registry is nothing, use abbreivated URN; otherwise, expand identifier to full Cite2Urn.\n\n@(SIGNATURES) Required for CitableTrait.\n\n\n\n\n\nCompose CEX text for a NounStem. If registry is nothing, use abbreivated URN; otherwise, expand identifier to full Cite2Urn.\n\n@(SIGNATURES) Required for CitableTrait.\n\n\n\n\n\nCompose CEX text for an IrregularNounStem. If registry is nothing, use abbreivated URN; otherwise, expand identifier to full Cite2Urn.\n\n@(SIGNATURES) Required for CitableTrait.\n\n\n\n\n\nCompose CEX text for a NounRule. If registry is nothing, use abbreivated URN; otherwise, expand identifier to full Cite2Urn.\n\n@(SIGNATURES) Required for CitableTrait.\n\n\n\n\n\nCompose CEX text for an AdjectiveRule. If registry is nothing, use abbreivated URN; otherwise, expand identifier to full Cite2Urn.\n\n@(SIGNATURES) Required for CitableTrait.\n\n\n\n\n\nCompose CEX text for an AdjectiveStem. If registry is nothing, use abbreivated URN; otherwise, expand identifier to full Cite2Urn.\n\n@(SIGNATURES) Required for CitableTrait.\n\n\n\n\n\nCompose CEX text for an IrregularAdjectiveStem. If registry is nothing, use abbreivated URN; otherwise, expand identifier to full Cite2Urn.\n\n@(SIGNATURES) Required for CitableTrait.\n\n\n\n\n\nCompose CEX text for a PronounStem. If registry is nothing, use abbreivated URN; otherwise, expand identifier to full Cite2Urn.\n\n@(SIGNATURES) Required for CitableTrait.\n\n\n\n\n\nCompose CEX text for a PronounRule. If registry is nothing, use abbreivated URN; otherwise, expand identifier to full Cite2Urn.\n\n@(SIGNATURES) Required for CitableTrait.\n\n\n\n\n\nCompose CEX text for a UninflectedStem. If registry is nothing, use abbreivated URN; otherwise, expand identifier to full Cite2Urn.\n\n@(SIGNATURES) Required for CitableTrait.\n\n\n\n\n\nCompose CEX text for a NounRule. If registry is nothing, use abbreivated URN; otherwise, expand identifier to full Cite2Urn.\n\n@(SIGNATURES) Required for CitableTrait.\n\n\n\n\n\n","category":"function"},{"location":"apis/apis/#Kanones.ruleurn","page":"Julia API documentation","title":"Kanones.ruleurn","text":"Generic function to convert form information in a Rule to a RuleUrn.\n\nruleurn(rule)\n\n\n\n\n\n\nCompose an abbreviated URN for a rule from an InfinitiveRule.\n\nruleurn(rule)\n\n\n\n\n\n\nCompose an abbreviated URN for a rule from a NounRule.\n\nruleurn(rule)\n\n\n\n\n\n\nCompose an abbreviated URN for a rule from a NounRule.\n\nruleurn(rule)\n\n\n\n\n\n\nCompose an abbreviated URN for a rule from a NounRule.\n\nruleurn(rule)\n\n\n\n\n\n\nCompose an abbreviated URN for a rule from a AdjectiveRule.\n\nruleurn(rule)\n\n\n\n\n\n\nCompose an abbreviated URN for a rule from a PronounStem.\n\nruleurn(rule)\n\n\n\n\n\n\n","category":"function"},{"location":"apis/apis/#Kanones.formscex","page":"Julia API documentation","title":"Kanones.formscex","text":"Compose CEX representation of CITE colletion of all recognized forms.\n\nformscex()\n\n\nCurrently, includes only:\n\nunanalyzed forms\nuninflected forms\nnoun forms\ninflected verb forms\n\n\n\n\n\n","category":"function"},{"location":"apis/apis/#Kanones.formurn","page":"Julia API documentation","title":"Kanones.formurn","text":"Generic function to convert form information in a GreekMorphologicalForm to a FormUrn.\n\nformurn(rule)\n\n\n\n\n\n\nCompose a FormUrn for a GMFFiniteVerb.\n\nformurn(verbform)\n\n\n\n\n\n\nCompose a FormUrn for an GMFInfinitive.\n\nformurn(infinitive)\n\n\n\n\n\n\nCompose a FormUrn for an GMFInfinitive.\n\nformurn(ptcpl)\n\n\n\n\n\n\nCompose a FormUrn for an GMFVerbalAdjective.\n\nformurn(vadj)\n\n\n\n\n\n\nCompose a FormUrn for a GMFNoun.\n\nformurn(gmfNoun)\n\n\n\n\n\n\nCompose a FormUrn for an GMFAdjective.\n\nformurn(adj)\n\n\n\n\n\n\nCompose a FormUrn for a GMFPronoun.\n\nformurn(gmfPronoun)\n\n\n\n\n\n\nCompose a FormUrn for an GMFUninflected.\n\nformurn(uninflected)\n\n\n\n\n\n\n","category":"function"},{"location":"apis/apis/#Kanones.gmfNoun","page":"Julia API documentation","title":"Kanones.gmfNoun","text":"Create a GMFNoun from a string value.\n\ngmfNoun(code)\n\n\n\n\n\n\nCreate a GMFNoun from a Cite2Urn.\n\ngmfNoun(urn)\n\n\n\n\n\n\nCreate a GMFNoun from a FormUrn.\n\ngmfNoun(f)\n\n\n\n\n\n\nCreate a GMFNoun from an Analysis.\n\ngmfNoun(a)\n\n\n\n\n\n\n","category":"function"},{"location":"apis/apis/#Kanones.nounscex","page":"Julia API documentation","title":"Kanones.nounscex","text":"Compose CEX representation of URNs and labels for noun forms.\n\nnounscex()\n\n\n\n\n\n\n","category":"function"},{"location":"apis/apis/#Kanones.gmfUninflected","page":"Julia API documentation","title":"Kanones.gmfUninflected","text":"Create GMFUninflected from a Cite2Urn.\n\ngmfUninflected(urn)\n\n\n\n\n\n\nCreate GMFUninflected from a FormUrn.\n\ngmfUninflected(u)\n\n\n\n\n\n\nCreate GMFUninflected from a string value.\n\ngmfUninflected(codeString)\n\n\n\n\n\n\nCreate GMFUninflected from a Char.\n\ngmfUninflected(ch)\n\n\n\n\n\n\nCreate GMFUninflected from an Int.\n\ngmfUninflected(code)\n\n\n\n\n\n\nCreate GMFUninflected from an Analysis.\n\ngmfUninflected(a)\n\n\n\n\n\n\n","category":"function"},{"location":"apis/apis/#Kanones.uninflectedcex","page":"Julia API documentation","title":"Kanones.uninflectedcex","text":"Compose CEX representation of URNs and labels for uninflected forms.\n\nuninflectedcex()\n\n\n\n\n\n\n","category":"function"},{"location":"apis/apis/#Datasets","page":"Julia API documentation","title":"Datasets","text":"","category":"section"},{"location":"apis/apis/#Structures-2","page":"Julia API documentation","title":"Structures","text":"","category":"section"},{"location":"apis/apis/","page":"Julia API documentation","title":"Julia API documentation","text":"Kanones.Dataset\nKanones.KanonesIO\nKanones.NounIO\nKanones.NounStem\nKanones.NounRule\nKanones.UninflectedIO\nKanones.UninflectedStem\nKanones.UninflectedRule\nKanones.VerbIO","category":"page"},{"location":"apis/apis/#Kanones.Dataset","page":"Julia API documentation","title":"Kanones.Dataset","text":"A Kanones dataset in a local file system.  \n\nMembers\n\ndirs is a list of full paths to the root directory of one or more datasets.  \n\nTheir subdirectory organization must follow Kanones' specifications.\n\northography is an implementation of the GreekOrthography interface\n\n\n\n\n\n","category":"type"},{"location":"apis/apis/#Kanones.KanonesIO","page":"Julia API documentation","title":"Kanones.KanonesIO","text":"Implementations of this type can read delimited text and write SFST.\n\n\n\n\n\n","category":"type"},{"location":"apis/apis/#Kanones.NounIO","page":"Julia API documentation","title":"Kanones.NounIO","text":"KanonesIO type for reading and writing data for regular noun forms.\n\n\n\n\n\n","category":"type"},{"location":"apis/apis/#Kanones.NounStem","page":"Julia API documentation","title":"Kanones.NounStem","text":"A record for a single noun stem.\n\n\n\n\n\n","category":"type"},{"location":"apis/apis/#Kanones.NounRule","page":"Julia API documentation","title":"Kanones.NounRule","text":"Inflectional rule for a noun rule.\n\n\n\n\n\n","category":"type"},{"location":"apis/apis/#Kanones.UninflectedIO","page":"Julia API documentation","title":"Kanones.UninflectedIO","text":"KanonesIO type for reading and writing stem for uninflected forms.\n\n\n\n\n\n","category":"type"},{"location":"apis/apis/#Kanones.UninflectedStem","page":"Julia API documentation","title":"Kanones.UninflectedStem","text":"A record for a single uninflected stem.\n\n\n\n\n\n","category":"type"},{"location":"apis/apis/#Kanones.UninflectedRule","page":"Julia API documentation","title":"Kanones.UninflectedRule","text":"Inflectional rule for uninflected lexical items.\n\n\n\n\n\n","category":"type"},{"location":"apis/apis/#Kanones.VerbIO","page":"Julia API documentation","title":"Kanones.VerbIO","text":"KanonesIO type for reading and writing data for finite verb form.\n\n\n\n\n\n","category":"type"},{"location":"apis/apis/#Functions-2","page":"Julia API documentation","title":"Functions","text":"","category":"section"},{"location":"apis/apis/","page":"Julia API documentation","title":"Julia API documentation","text":"Exported: ","category":"page"},{"location":"apis/apis/","page":"Julia API documentation","title":"Julia API documentation","text":"dataset\nrulesarray\nstemsarray","category":"page"},{"location":"apis/apis/#Kanones.dataset","page":"Julia API documentation","title":"Kanones.dataset","text":"Create a Kanones.Dataset from a single data source.\n\ndataset(dir; ortho)\n\n\nArguments\n\ndir Full path to a directory with Kanones data.\northo An instance of a GreekOrthography; defaults to LiteraryGreekOrthography.\n\n\n\n\n\nCreate a Kanones.Dataset from one or more data sources.\n\ndataset(srclist; ortho)\n\n\nArguments\n\nsrclist List of full paths to a directory with Kanones data.\northo An instance of a GreekOrthography; defaults to LiteraryGreekOrthography.\n\n\n\n\n\n","category":"function"},{"location":"apis/apis/#Kanones.rulesarray","page":"Julia API documentation","title":"Kanones.rulesarray","text":"Read all rules data from a list of directories into an array of Rules.\n\nrulesarray(kd; delimiter)\n\n\n\n\n\n\nRead all rules data from a Kanones.Dataset into an array of Rules.\n\nrulesarray(dirlist; delimiter)\n\n\n\n\n\n\n","category":"function"},{"location":"apis/apis/#Kanones.stemsarray","page":"Julia API documentation","title":"Kanones.stemsarray","text":"Read all stem data from a list of directories into an array of Stems.\n\nstemsarray(kd)\n\n\n\n\n\n\nRead all stem data from a Kanones.Dataset into an array of Stems.\n\nstemsarray(dirlist; delimiter)\n\n\n\n\n\n\n","category":"function"},{"location":"apis/apis/","page":"Julia API documentation","title":"Julia API documentation","text":"Internals:","category":"page"},{"location":"apis/apis/","page":"Julia API documentation","title":"Julia API documentation","text":"Kanones.readstemrow\nKanones.readrulerow\nKanones.id\nKanones.lexeme\nKanones.abbrformurn","category":"page"},{"location":"apis/apis/#Kanones.readstemrow","page":"Julia API documentation","title":"Kanones.readstemrow","text":"Implementation of reading one row of a stems table for finite verbs.\n\nreadstemrow(usp, delimited; delimiter)\n\n\n\n\n\n\nRead one row of a stems table for irregular infinititve tokens and create an IrregularInfinitiveStem.\n\nreadstemrow(infinio, delimited; delimiter)\n\n\n\n\n\n\nRead one row of a stems table for noun tokens and create a NounStem.\n\nreadstemrow(usp, delimited; delimiter)\n\n\n\n\n\n\nRead one row of a stems table for noun tokens and create a NounStem.\n\nreadstemrow(usp, delimited; delimiter)\n\n\n\n\n\n\nRead one row of a stems table for adjective tokens and create an AdjectiveStem.\n\nreadstemrow(usp, delimited; delimiter)\n\n\n\n\n\n\nRead one row of a stems table for irregular adjective tokens and create an AdjectiveStem.\n\nreadstemrow(usp, delimited; delimiter)\n\n\n\n\n\n\nRead one row of a stems table for noun tokens and create a PronounStem.\n\nreadstemrow(usp, delimited; delimiter)\n\n\n\n\n\n\nImplementation of reading one row of a stems table for uninflected tokens.\n\nreadstemrow(usp, delimited; delimiter)\n\n\n\n\n\n\n","category":"function"},{"location":"apis/apis/#Kanones.readrulerow","page":"Julia API documentation","title":"Kanones.readrulerow","text":"Implementation of reading one row of a rules table for irregular tokens.\n\nreadrulerow(ruleparser, delimited; delimiter)\n\n\n\n\n\n\nRead one row of a rules table for verb tokens and create a FiniteVerbRule\n\nreadrulerow(usp, delimited; delimiter)\n\n\n\n\n\n\nRead one row of a rules table for infinitives and create an InfinitiveRule.\n\nreadrulerow(infio, delimited; delimiter)\n\n\n\n\n\n\nRead one row of a rules table for infinitives and create anParticipleRule.\n\nreadrulerow(usp, delimited; delimiter)\n\n\n\n\n\n\nRead one row of a rules table for infinitives and create an InfinitiveRule.\n\nreadrulerow(usp, delimited; delimiter)\n\n\n\n\n\n\nRead one row of a rules table for noun tokens, and create a NounRule.\n\nreadrulerow(usp, delimited; delimiter)\n\n\n\n\n\n\nImplementation of reading one row of a rules table for uninflected tokens.\n\nreadrulerow(usp, delimited; delimiter)\n\n\n\n\n\n\nRead one row of a stems table for pronoun tokens and create a PronounRule.\n\nreadrulerow(usp, delimited; delimiter)\n\n\n\n\n\n\nImplementation of reading one row of a rules table for uninflected tokens.\n\nreadrulerow(usp, delimited; delimiter)\n\n\n\n\n\n\n","category":"function"},{"location":"apis/apis/#Kanones.id","page":"Julia API documentation","title":"Kanones.id","text":"Identifier for a NounStem, as an abbreviated URN.\n\nid(n)\n\n\n\n\n\n\nIdentifier for a  NounRule, as an abbreviated URN.\n\nid(n)\n\n\n\n\n\n\nIdentifier string for an UninflectedStem.\n\nid(uninfl)\n\n\n\n\n\n\nIdentify identifier URN for an UninflectedRule.\n\nid(uninfl)\n\n\n\n\n\n\n","category":"function"},{"location":"apis/apis/#Kanones.lexeme","page":"Julia API documentation","title":"Kanones.lexeme","text":"Lexeme for a NounStem, as an  abbreviated URN.\n\nlexeme(n)\n\n\n\n\n\n\nIdentify lexeme URN for an UninflectedStem.\n\nlexeme(uninfl)\n\n\n\n\n\n\n","category":"function"},{"location":"apis/apis/#Analysis","page":"Julia API documentation","title":"Analysis","text":"","category":"section"},{"location":"apis/apis/#Exported-functions","page":"Julia API documentation","title":"Exported functions","text":"","category":"section"},{"location":"apis/apis/","page":"Julia API documentation","title":"Julia API documentation","text":"parsetoken\nparsewordlist\nparsedocument\nparsecorpus","category":"page"},{"location":"apis/apis/#CitableParserBuilder.parsetoken","page":"Julia API documentation","title":"CitableParserBuilder.parsetoken","text":"Delegate to specific functions based on type's citable trait value.\n\nparsetoken(s, x; data)\n\n\n\n\n\n\nIt is an error to invoke the parsetoken using types that are not a parser.\n\nparsetoken(, s, x; data)\n\n\n\n\n\n\nCitable parsers must implement parsetoken.\n\nparsetoken(, s, x; data)\n\n\n\n\n\n\nParse String s by looking it up in a given dictionary.\n\n\n\n\n\nParse a single token to an array of Analysis or nothing.\n\nparsetoken(tkn, parser; data)\n\n\n\n\n\n\n","category":"function"},{"location":"apis/apis/#CitableParserBuilder.parsewordlist","page":"Julia API documentation","title":"CitableParserBuilder.parsewordlist","text":"Parse a list of tokens with a CitableParser.\n\nparsewordlist(vocablist, p; data, countinterval)\n\n\nReturns a Dict mapping strings to a (possibly empty) vector of Analysis objects.\n\n\n\n\n\nOverride implementation in CitableParser.\n\nparsewordlist(vocablist, parser; data, countinterval)\n\n\nReturns a Dict mapping strings to a (possibly empty) vector of Analysis objects.\n\n\n\n\n\n","category":"function"},{"location":"apis/apis/#CitableParserBuilder.parsedocument","page":"Julia API documentation","title":"CitableParserBuilder.parsedocument","text":"Use a CitableParser to parse a CitableTextCorpus with each citable node containing containg a single token.\n\nparsedocument(doc, p; data, countinterval)\n\n\nShould return a list of AnalyzedTokens.\n\n\n\n\n\nOverride implementation in CitableParserBuilder.\n\nparsedocument(doc, p; data, countinterval)\n\n\nShould return a list of AnalyzedTokens.\n\n\n\n\n\n","category":"function"},{"location":"apis/apis/#CitableParserBuilder.parsecorpus","page":"Julia API documentation","title":"CitableParserBuilder.parsecorpus","text":"Use a CitableParser to parse a CitableTextCorpus with each citable node containing containg a single token.\n\nparsecorpus(c, p; data, countinterval)\n\n\nShould return a list of AnalyzedTokens.\n\n\n\n\n\nOverride implementation in CitableParserBuilder.\n\nparsecorpus(c, p; data, countinterval)\n\n\nShould return a list of AnalyzedTokens.\n\n\n\n\n\n","category":"function"},{"location":"apis/apis/#Functions-used-internally-in-parsing-via-a-FST","page":"Julia API documentation","title":"Functions used internally in parsing via a FST","text":"","category":"section"},{"location":"apis/apis/","page":"Julia API documentation","title":"Julia API documentation","text":"Kanones.stemsforlex\nKanones.fstinflpath\nKanones.echopath\nKanones.functionforcategory\nKanones.parsefst\nKanones.applyparser","category":"page"},{"location":"apis/apis/#Kanones.stemsforlex","page":"Julia API documentation","title":"Kanones.stemsforlex","text":"Find stems for a given lexeme.\n\nstemsforlex(lex, stems)\n\n\n\n\n\n\n","category":"function"},{"location":"apis/apis/#Kanones.fstinflpath","page":"Julia API documentation","title":"Kanones.fstinflpath","text":"Find full path to fst-inflon your system.\n\nfstinflpath()\n\n\n\n\n\n\n","category":"function"},{"location":"apis/apis/#Kanones.echopath","page":"Julia API documentation","title":"Kanones.echopath","text":"Find full path to echoon your system.\n\nechopath()\n\n\n\n\n\n\n","category":"function"},{"location":"apis/apis/#Kanones.functionforcategory","page":"Julia API documentation","title":"Kanones.functionforcategory","text":"Dictionary of functions to use with each analytical type to determine a FormUrn from the FST description of form.\n\nfunctionforcategory()\n\n\n\n\n\n\n","category":"function"},{"location":"apis/apis/#Kanones.parsefst","page":"Julia API documentation","title":"Kanones.parsefst","text":"Parse a string of FST output for a single token to a list of Analysis objects.\n\nparsefst(fststring)\n\n\n\n\n\n\n","category":"function"},{"location":"apis/apis/#Kanones.applyparser","page":"Julia API documentation","title":"Kanones.applyparser","text":"Apply a parser to a token using fst-infl. Suppress standard error since this generates show-stopping IO demands if routed to terminal.\n\napplyparser(tkn, parser)\n\n\n\n\n\n\nUses the external fst-infl command to apply parser to a list of vocabulary, and returns the string output of fst-infl.\n\napplyparser(vocablist, parser)\n\n\n\n\n\n\n","category":"function"},{"location":"apis/apis/#Generation","page":"Julia API documentation","title":"Generation","text":"","category":"section"},{"location":"apis/apis/","page":"Julia API documentation","title":"Julia API documentation","text":"Exported:","category":"page"},{"location":"apis/apis/","page":"Julia API documentation","title":"Julia API documentation","text":"generate","category":"page"},{"location":"apis/apis/#Kanones.generate","page":"Julia API documentation","title":"Kanones.generate","text":"Generate a string for the form of a given Analysis using a given dataset.\n\ngenerate(analysis, kd)\n\n\n\n\n\n\nGenerate a string for a given form and lexeme using a given dataset.\n\ngenerate(form, lex, kd)\n\n\n\n\n\n\n","category":"function"},{"location":"apis/apis/","page":"Julia API documentation","title":"Julia API documentation","text":"Internal:","category":"page"},{"location":"apis/apis/","page":"Julia API documentation","title":"Julia API documentation","text":"Kanones.generateuninflected\nKanones.generatenoun","category":"page"},{"location":"apis/apis/#Kanones.generateuninflected","page":"Julia API documentation","title":"Kanones.generateuninflected","text":"Generate vector of possible strings for correctly accented form of uninflected token identified by analysis.\n\ngenerateuninflected(analysis, kd; ortho)\n\n\nBecause uninflected  forms record a full, accented string in their stem record, all we have to do is find matching stem records, and extract their form members.\n\n\n\n\n\n","category":"function"},{"location":"apis/apis/#Kanones.generatenoun","page":"Julia API documentation","title":"Kanones.generatenoun","text":"Generate vector of possible strings for correctly accented form of a noun form identified by lexeme.\n\ngeneratenoun(form, lex, kd)\n\n\n\n\n\n\nGenerate vector of possible strings for correctly accented form of a noun form identified by analysis.\n\ngeneratenoun(analysis, kd)\n\n\n\n\n\n\n","category":"function"},{"location":"apis/apis/#Kanones.FstBuilder","page":"Julia API documentation","title":"Kanones.FstBuilder","text":"","category":"section"},{"location":"apis/apis/","page":"Julia API documentation","title":"Julia API documentation","text":"The functions of the FstBuilder submodule compose expressions in SFST-PL, the language of the Stuttgart FST toolkit.","category":"page"},{"location":"apis/apis/","page":"Julia API documentation","title":"Julia API documentation","text":"Kanones.FstBuilder.buildparser\nKanones.FstBuilder.buildlexicon\nKanones.FstBuilder.buildinflection\nKanones.FstBuilder.buildfinalfst\nKanones.FstBuilder.buildmakefile\nKanones.FstBuilder.compilefst\nKanones.FstBuilder.buildacceptor\nKanones.FstBuilder.uninflsquasher\nKanones.FstBuilder.nounsquasher\nKanones.FstBuilder.installalphabet\nKanones.FstBuilder.installsymbols\nKanones.FstBuilder.symbolsfst\nKanones.FstBuilder.fstok\nKanones.FstBuilder.cmdok\nKanones.FstBuilder.fst\nKanones.FstBuilder.addsmooth\nKanones.FstBuilder.addrough\nKanones.FstBuilder.greekfromfst\nKanones.FstBuilder.fstgreek","category":"page"},{"location":"apis/apis/#Kanones.FstBuilder.buildparser","page":"Julia API documentation","title":"Kanones.FstBuilder.buildparser","text":"Read data from src and fstdir and compile a SFST parser in target.\n\nbuildparser(src, fstdir, target)\nbuildparser(src, fstdir, target, label; force)\n\n\nReturns the path to the compiled binary greek.a which can then be used as an argument to the parsetoken function.\n\n\n\n\n\n","category":"function"},{"location":"apis/apis/#Kanones.FstBuilder.buildlexicon","page":"Julia API documentation","title":"Kanones.FstBuilder.buildlexicon","text":"Read all stem data and compose lexicon.fst.\n\nbuildlexicon(src, target)\n\n\nArguments\n\nsrc is a Kanones.Dataset.  \ntarget is the full path to the desination file lexicon.fst.\n\n\n\n\n\n","category":"function"},{"location":"apis/apis/#Kanones.FstBuilder.buildinflection","page":"Julia API documentation","title":"Kanones.FstBuilder.buildinflection","text":"Read all rules data and compose inflection.fst.\n\nbuildinflection(src, target)\n\n\nArguments\n\nsrc is a Kanones.Dataset.  \ntarget is the full path to the desination file inflection.fst.\n\n\n\n\n\n","category":"function"},{"location":"apis/apis/#Kanones.FstBuilder.buildfinalfst","page":"Julia API documentation","title":"Kanones.FstBuilder.buildfinalfst","text":"Compose top-level transducer greek.fst.\n\nbuildfinalfst(target)\n\n\nArguments\n\ntarget is the full path to the desination file greek.fst.\n\n\n\n\n\n","category":"function"},{"location":"apis/apis/#Kanones.FstBuilder.buildmakefile","page":"Julia API documentation","title":"Kanones.FstBuilder.buildmakefile","text":"Compose makefile.\n\nbuildmakefile(target)\n\n\nArguments\n\nsrc is a Kanones.Dataset.  \ntarget is the full path to the desination file makefile.\n\n\n\n\n\n","category":"function"},{"location":"apis/apis/#Kanones.FstBuilder.compilefst","page":"Julia API documentation","title":"Kanones.FstBuilder.compilefst","text":"Compile binary parser with make.\n\ncompilefst(target)\n\n\nArguments\n\ntarget is a directory with a makefile.\n\n\n\n\n\n","category":"function"},{"location":"apis/apis/#Kanones.FstBuilder.buildacceptor","page":"Julia API documentation","title":"Kanones.FstBuilder.buildacceptor","text":"Compose acceptor.fst and write to file target.\n\nbuildacceptor(target)\n\n\n\n\n\n\n","category":"function"},{"location":"apis/apis/#Kanones.FstBuilder.uninflsquasher","page":"Julia API documentation","title":"Kanones.FstBuilder.uninflsquasher","text":"Compose transducer for filtering uninflected forms.\n\nuninflsquasher()\n\n\n\n\n\n\n","category":"function"},{"location":"apis/apis/#Kanones.FstBuilder.nounsquasher","page":"Julia API documentation","title":"Kanones.FstBuilder.nounsquasher","text":"Compose transducer for filtering nouns.\n\nnounsquasher()\n\n\n\n\n\n\n","category":"function"},{"location":"apis/apis/#Kanones.FstBuilder.installalphabet","page":"Julia API documentation","title":"Kanones.FstBuilder.installalphabet","text":"Install alphabet.fst required to be part of an individual project.\n\ninstallalphabet(src, target)\n\n\n\n\n\n\n","category":"function"},{"location":"apis/apis/#Kanones.FstBuilder.installsymbols","page":"Julia API documentation","title":"Kanones.FstBuilder.installsymbols","text":"Install symbols FST from generic FST source applying to many projects.\n\ninstallsymbols(src, target)\n\n\n\n\n\n\n","category":"function"},{"location":"apis/apis/#Kanones.FstBuilder.symbolsfst","page":"Julia API documentation","title":"Kanones.FstBuilder.symbolsfst","text":"Compose content for top-level symbols.fst file.\n\nsymbolsfst(dir)\n\n\n\n\n\n\n","category":"function"},{"location":"apis/apis/#Kanones.FstBuilder.fstok","page":"Julia API documentation","title":"Kanones.FstBuilder.fstok","text":"True if all necessary SFST components are installed.\n\nfstok()\n\n\n\n\n\n\n","category":"function"},{"location":"apis/apis/#Kanones.FstBuilder.cmdok","page":"Julia API documentation","title":"Kanones.FstBuilder.cmdok","text":"True if executable cmd is found.\n\ncmdok(cmd)\n\n\n\n\n\n\n","category":"function"},{"location":"apis/apis/#Kanones.FstBuilder.fst","page":"Julia API documentation","title":"Kanones.FstBuilder.fst","text":"Compose FST representation of a single UniflectedStem.\n\nfst(stem; ortho)\n\n\n\n\n\n\nCompose FST representation of a single UninflectedRule.\n\nfst(rule; ortho)\n\n\n\n\n\n\nCompose FST representation of a single NounStem.\n\nfst(stem; ortho)\n\n\n\n\n\n\nCompose FST representation of a single NounRule.\n\nfst(rule; ortho)\n\n\n\n\n\n\nCompose FST representation of a single PronounStem.\n\nfst(stem; ortho)\n\n\n\n\n\n\nCompose FST representation of a single PronounRule.\n\nfst(rule; ortho)\n\n\n\n\n\n\nCompose FST representation of a single AdjectiveStem.\n\nfst(stem; ortho)\n\n\n\n\n\n\nCompose FST representation of a single AdjectiveRule.\n\nfst(rule; ortho)\n\n\n\n\n\n\nCompose FST representation of a single IrregularAdjectiveStem.\n\nfst(stem; ortho)\n\n\n\n\n\n\nCompose FST representation of a single IrregularNounStem.\n\nfst(stem; ortho)\n\n\n\n\n\n\nCompose FST representation of a single IrregularVerbStem.\n\nfst(stem; ortho)\n\n\n\n\n\n\nCompose FST representation of a single IrregularVerbStem.\n\nfst(stem; ortho)\n\n\n\n\n\n\nCompose FST representation of a single UninflectedRule.\n\nfst(rule; ortho)\n\n\n\n\n\n\nCompose FST representation of a single VerbStem.\n\nfst(stem; ortho)\n\n\n\n\n\n\nCompose FST representation of a single VerbRule.\n\nfst(rule; ortho)\n\n\n\n\n\n\nCompose FST representation of a single InfinitiveRule.\n\nfst(rule; ortho)\n\n\n\n\n\n\nCompose FST representation of a single ParticipleRule.\n\nfst(rule; ortho)\n\n\n\n\n\n\nCompose FST representation of a single InfinitiveRule.\n\nfst(rule; ortho)\n\n\n\n\n\n\n","category":"function"},{"location":"apis/apis/#Kanones.FstBuilder.addsmooth","page":"Julia API documentation","title":"Kanones.FstBuilder.addsmooth","text":"Add smooth breathing to a vowel.\n\naddsmooth(vowel)\n\n\n\n\n\n\n","category":"function"},{"location":"apis/apis/#Kanones.FstBuilder.addrough","page":"Julia API documentation","title":"Kanones.FstBuilder.addrough","text":"Add rough breathing to a vowel.\n\naddrough(vowel)\n\n\n\n\n\n\n","category":"function"},{"location":"apis/apis/#Kanones.FstBuilder.greekfromfst","page":"Julia API documentation","title":"Kanones.FstBuilder.greekfromfst","text":"Convert FST string to Unicode representation of Greek.\n\ngreekfromfst(fst)\n\n\n\n\n\n\n","category":"function"},{"location":"apis/apis/#Kanones.FstBuilder.fstgreek","page":"Julia API documentation","title":"Kanones.FstBuilder.fstgreek","text":"Convert Greek string s to FST representation.\n\nfstgreek(s)\nfstgreek(s, ortho)\n\n\n\n\n\n\n","category":"function"},{"location":"implementation/overview/#Programmer's-notes-on-implementation","page":"Programmer's notes on implementation","title":"Programmer's notes on implementation","text":"","category":"section"},{"location":"implementation/overview/","page":"Programmer's notes on implementation","title":"Programmer's notes on implementation","text":"Kanones is designed so that corpus-specific datasets can be managed from delimited text files.  Normally, end-users will build a parser directly from these files with the buildparser function, and then work with the output of the parser as objects such as AnalyzedTokens, or a pairing of a string with an Analysis.","category":"page"},{"location":"implementation/overview/","page":"Programmer's notes on implementation","title":"Programmer's notes on implementation","text":"This section of the documentation illustrates what Kanones does behind the scene to make this happen.","category":"page"},{"location":"implementation/overview/","page":"Programmer's notes on implementation","title":"Programmer's notes on implementation","text":"repo = pwd() |> dirname |> dirname  |> dirname","category":"page"},{"location":"implementation/overview/#Reading-delimited-data-sets-from-delimited-text-files","page":"Programmer's notes on implementation","title":"Reading delimited data sets from delimited-text files","text":"","category":"section"},{"location":"implementation/overview/","page":"Programmer's notes on implementation","title":"Programmer's notes on implementation","text":"Data sets, organized as stem files and rule files for each analytical type (\"part of speech\"), are managed in delimited text files.  When a parser is built, Kanones reads these files and writes source code for an SFST compiler.  ","category":"page"},{"location":"implementation/overview/","page":"Programmer's notes on implementation","title":"Programmer's notes on implementation","text":"Directories of delimited-text files are managed with a Kanones.Dataset using a specified OrthographicSystem (default: LiteraryGreekOrthography).  This example uses an absolutely minimal dataset in the datasets/implementation-eg diretory of this repository: a stem for a single noun, and a single rule.  (You can browse the two source files on github here.)  The noun is the masculine noun ἄνθρωπος (lsj.n8909) and the only rule defined is for the formation of its genitive singular form.","category":"page"},{"location":"implementation/overview/","page":"Programmer's notes on implementation","title":"Programmer's notes on implementation","text":"using Kanones, Kanones.FstBuilder\nsampledatafiles = joinpath(repo,\"datasets\",\"implementation-eg\")\nkd = dataset([sampledatafiles])\ntypeof(kd)","category":"page"},{"location":"implementation/overview/","page":"Programmer's notes on implementation","title":"Programmer's notes on implementation","text":"The KanonesIO abstraction defines two functions to read data from delimited text sources (Kanones.readstemrow and Kanones.readrulerow), and can write data to SFST format with the fst function.  Let's see how this works.","category":"page"},{"location":"implementation/overview/#Parsing-delimited-text-to-objects-with-KanonesIO","page":"Programmer's notes on implementation","title":"Parsing delimited text to objects with KanonesIO","text":"","category":"section"},{"location":"implementation/overview/","page":"Programmer's notes on implementation","title":"Programmer's notes on implementation","text":"The readstemrow and readrulerow functions apply appropriate subtypes of the KanonesIO abstract type to read each subdirectory of a Kanones.Dataset:  stemsarray cycles through all the subdirectories of the dataset, and applies  the readstemrow function to the file contents of stem tables, while rulesarray  applies the readrulerow function to the contents of rules tables.  ","category":"page"},{"location":"implementation/overview/","page":"Programmer's notes on implementation","title":"Programmer's notes on implementation","text":"To read stems and rules data, we use subtypes of the KanonesIO abstraction.  In this example, the conventions for a dataset's layout dictate that the contents of the stems-tables/nouns directory should contain noun stems, so we'll read those files with a NounIO, which is a subtype of KanonesIO.","category":"page"},{"location":"implementation/overview/","page":"Programmer's notes on implementation","title":"Programmer's notes on implementation","text":"nounio = Kanones.NounIO(\"Reader/writer for noun data.\")\ntypeof(nounio) |> supertype","category":"page"},{"location":"implementation/overview/","page":"Programmer's notes on implementation","title":"Programmer's notes on implementation","text":"Here's the one data line included in our source data for lexicon stems.  When we read the data with readstemrow, the result will be a subtype of the CitableParserBuilder.Stem abstract type.","category":"page"},{"location":"implementation/overview/","page":"Programmer's notes on implementation","title":"Programmer's notes on implementation","text":"stemdata = \"nounstems.n8909|lsj.n8909|ἀνθρωπ|masculine|os_ou|recessive|\"\nstem = Kanones.readstemrow(nounio, stemdata)\nstem |> typeof |> supertype","category":"page"},{"location":"implementation/overview/","page":"Programmer's notes on implementation","title":"Programmer's notes on implementation","text":"Similarly, when we use the NounIO object to read a row of rules data, we get a subtype of CitableParserBuilder.Rule. ","category":"page"},{"location":"implementation/overview/","page":"Programmer's notes on implementation","title":"Programmer's notes on implementation","text":"ruledata = \"nouninfl.os_ou2|os_ou|ου|masculine|genitive|singular|\"\nrule = Kanones.readrulerow(nounio, ruledata)\nrule |> typeof |> supertype","category":"page"},{"location":"implementation/overview/","page":"Programmer's notes on implementation","title":"Programmer's notes on implementation","text":"This allows the stemsarray and rulesarray functions to read all stems and rules into arrays of CitableParserBuilder.Stem and CitableParserBuilder.Rule objects, respectively.","category":"page"},{"location":"implementation/overview/","page":"Programmer's notes on implementation","title":"Programmer's notes on implementation","text":"stems = Kanones.stemsarray(kd)\ntypeof(stems)","category":"page"},{"location":"implementation/overview/","page":"Programmer's notes on implementation","title":"Programmer's notes on implementation","text":"In this instance, the single result  will be identical to the single example we previously constructed.","category":"page"},{"location":"implementation/overview/","page":"Programmer's notes on implementation","title":"Programmer's notes on implementation","text":"stems[1] == stem","category":"page"},{"location":"implementation/overview/","page":"Programmer's notes on implementation","title":"Programmer's notes on implementation","text":"Similarly for rules.","category":"page"},{"location":"implementation/overview/","page":"Programmer's notes on implementation","title":"Programmer's notes on implementation","text":"rules = Kanones.rulesarray(kd)\ntypeof(rules)","category":"page"},{"location":"implementation/overview/","page":"Programmer's notes on implementation","title":"Programmer's notes on implementation","text":"rules[1] == rule","category":"page"},{"location":"implementation/overview/#Writing-SFST-source-files","page":"Programmer's notes on implementation","title":"Writing SFST source files","text":"","category":"section"},{"location":"implementation/overview/","page":"Programmer's notes on implementation","title":"Programmer's notes on implementation","text":"The Kanones.KanonesFstBuilder.fst formats Stem and Rule objects in the SFST language, and works with all the Kanones' subtypes of the Stem and Rule types.  As these examples illustrate, values are translated either to individual symbols (such as <noun> or <masculine>), or to formatted strings (such as URN values), with appropriate escaping of SFST metacharacters and normalization to Unicode NFKC.","category":"page"},{"location":"implementation/overview/","page":"Programmer's notes on implementation","title":"Programmer's notes on implementation","text":"Kanones.FstBuilder.fst(stem)","category":"page"},{"location":"implementation/overview/","page":"Programmer's notes on implementation","title":"Programmer's notes on implementation","text":"Kanones.FstBuilder.fst(rule)","category":"page"},{"location":"implementation/overview/","page":"Programmer's notes on implementation","title":"Programmer's notes on implementation","text":"When the source files for a parser are composed, the SFST code for stems are combined in SFST's \"lexicon\" format (one entry per line, and written to lexicon.fst. Rules files are combined as source for a single transducer that is the disjunction of all possible inflectional rules, and written to inflection.fst.  ","category":"page"},{"location":"implementation/overview/","page":"Programmer's notes on implementation","title":"Programmer's notes on implementation","text":"The buildparser function additionally composes the SFST logic for filtering out only valid combinations of stems + rules in acceptor.fst, and the final transducer in greek.fst, as well as a make file which it then uses to compile the binary parser.","category":"page"},{"location":"implementation/overview/#Reading-the-output-of-an-SFST-parser","page":"Programmer's notes on implementation","title":"Reading the output of an SFST parser","text":"","category":"section"},{"location":"implementation/overview/","page":"Programmer's notes on implementation","title":"Programmer's notes on implementation","text":"When a Kanones parser parses a token, the SFST parser returns line-oriented string data that looks like this:","category":"page"},{"location":"implementation/overview/","page":"Programmer's notes on implementation","title":"Programmer's notes on implementation","text":"rawreply = \"> ἀνθρωπου\\n<u>nounstems.n8909</u><u>lsj.n8909</u>ἀνθρωπ<noun><masculine><os_ou><div><os_ou><noun>ου<masculine><genitive><singular><u>nouninfl.os_ou2</u>\\n\"","category":"page"},{"location":"implementation/overview/","page":"Programmer's notes on implementation","title":"Programmer's notes on implementation","text":"For successful parses, lines beginning with > identify the token being parsed; subsequent lines list one successful parse per line.","category":"page"},{"location":"implementation/overview/","page":"Programmer's notes on implementation","title":"Programmer's notes on implementation","text":"lines = split(rawreply,\"\\n\")","category":"page"},{"location":"implementation/overview/","page":"Programmer's notes on implementation","title":"Programmer's notes on implementation","text":"Several functions parse data like this by passing non-empty lines with parse output to Kanones.analysisforline – here, the second line of the reply.","category":"page"},{"location":"implementation/overview/","page":"Programmer's notes on implementation","title":"Programmer's notes on implementation","text":"lines[2]","category":"page"},{"location":"implementation/overview/","page":"Programmer's notes on implementation","title":"Programmer's notes on implementation","text":"Stem and rule components are separated by the FST token <div>.  ","category":"page"},{"location":"implementation/overview/","page":"Programmer's notes on implementation","title":"Programmer's notes on implementation","text":"Kanones.analysisforline divides the reply into separate stem and rule components, and extracts the second token of the rule component to determine an analysis type – here, <noun>.","category":"page"},{"location":"implementation/overview/","page":"Programmer's notes on implementation","title":"Programmer's notes on implementation","text":"(stemfst, rulefst) = split(lines[2], \"<div>\")\nrule","category":"page"},{"location":"implementation/overview/","page":"Programmer's notes on implementation","title":"Programmer's notes on implementation","text":"The equivalent of what happens inside the Kanones.analysisforline is:","category":"page"},{"location":"implementation/overview/","page":"Programmer's notes on implementation","title":"Programmer's notes on implementation","text":"gmfNoun = Kanones.nounfromfst(\"<masculine><genitive><singular>\")","category":"page"},{"location":"implementation/overview/","page":"Programmer's notes on implementation","title":"Programmer's notes on implementation","text":"It uses a dictionary mapping names of analysis types to functions that can parse FST output for that analytical type into a FormUrn.  For analyses identifed by <noun>, it applies the Kanones.nounfromfst function.  These are versatile objects that can be used in many ways.","category":"page"},{"location":"implementation/overview/","page":"Programmer's notes on implementation","title":"Programmer's notes on implementation","text":"label(gmfNoun)","category":"page"},{"location":"implementation/overview/","page":"Programmer's notes on implementation","title":"Programmer's notes on implementation","text":"urn(gmfNoun)","category":"page"},{"location":"implementation/overview/","page":"Programmer's notes on implementation","title":"Programmer's notes on implementation","text":"cex(gmfNoun)","category":"page"},{"location":"implementation/overview/","page":"Programmer's notes on implementation","title":"Programmer's notes on implementation","text":"Kanones.formurn(gmfNoun)","category":"page"},{"location":"implementation/overview/#Validating-the-result:-analysis-through-synthesis","page":"Programmer's notes on implementation","title":"Validating the result: analysis through synthesis","text":"","category":"section"},{"location":"implementation/overview/","page":"Programmer's notes on implementation","title":"Programmer's notes on implementation","text":"TBA","category":"page"},{"location":"#Kanones.jl","page":"Home","title":"Kanones.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Build corpus-specific parsers for ancient Greek texts in a specified orthography.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Kanones.jl lets you build morphological parsers for ancient Greek.  It works with three central concepts: ","category":"page"},{"location":"","page":"Home","title":"Home","text":"An explicitly defined orthography.\nA morphological dataset (stems and inflectional rules) managed in plain-text tables.\nAnalyses recorded with URNs identifying lexemes, forms and the entries in the dataset leading the analysis.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Because Kanones.jl cleanly separates orthography and morphology, you can compile parsers for standard literary Greek, epichoric Greek alphabets, or Greek with manuscript symbols, for example.  Because it manages stems and inflectional rules in plain-text tables, an editor or Greek student can easily tailor a parser to a specific corpus by adding or deleting entries.  Because analyses are expressed with URNs, Kanones.jl's analytical tools can profile a corpus, and even compare lexical and morphological features across corpora in different orthographies. ","category":"page"},{"location":"#More-backgound","page":"Home","title":"More backgound","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Read more about the rationale and approach to parsing a historical language in \"Morphological Analysis of Historical Languages\" (Bulletin of the Institute for Classical Studies 59-2, 2016, 89-102).","category":"page"},{"location":"#Shortest-possible-example","page":"Home","title":"Shortest possible example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"note: Note\nThe example builds a parser using a sample dataset included in the Kanones.jl git repository.  See the user's manual for a fuller explanation .","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Kanones\nusing Kanones.FstBuilder\nusing CitableParserBuilder\nreporoot = pwd() |> dirname |> dirname\ntarget = reporoot * \"/parsers/demo/\"","category":"page"},{"location":"#Orthography-and-morphological-dataset","page":"Home","title":"Orthography and morphological dataset","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Load morphological data and definition of the dataset's orthography into a Kanones.Dataset structure.","category":"page"},{"location":"","page":"Home","title":"Home","text":"core_inflection = joinpath(reporoot, \"datasets\", \"core-infl\")\ncore_vocab = joinpath(reporoot, \"datasets\", \"core-vocab\")\nkd = dataset([core_inflection, core_vocab])\ntypeof(kd)","category":"page"},{"location":"#Compile-a-parser","page":"Home","title":"Compile a parser","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"identify a directory with the core FST files from the Kanones.jl repository\nidentify a target directory where you want to compile a parser\ncompile a parser. The binary FST parser will be named greek.a","category":"page"},{"location":"","page":"Home","title":"Home","text":"fstsrc = joinpath(reporoot,  \"fst\")\nparser = buildparser(kd, fstsrc, target)\nbasename(parser.sfstpath)","category":"page"}]
}
