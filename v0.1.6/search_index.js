var documenterSearchIndex = {"docs":
[{"location":"parsing/#Compiling-and-parsing","page":"Compiling and parsing","title":"Compiling and parsing","text":"","category":"section"},{"location":"parsing/","page":"Compiling and parsing","title":"Compiling and parsing","text":"Build a parser with the buildparser function.","category":"page"},{"location":"parsing/","page":"Compiling and parsing","title":"Compiling and parsing","text":"See Managing Kanones datasets","category":"page"},{"location":"parsing/","page":"Compiling and parsing","title":"Compiling and parsing","text":"repo = pwd() |> dirname |> dirname  |> dirname\ntarget = tempdir() * \"/demoparser2/\"\nif isdir(target)\n    rm(target, force=true, recursive=true)\n    mkdir(target)\nelse \n    mkdir(target)\nend","category":"page"},{"location":"parsing/","page":"Compiling and parsing","title":"Compiling and parsing","text":"using Kanones, Kanones.FstBuilder\nkd = dataset(repo * \"/datasets/core-infl/\")\nfstsrc = repo * \"/fst/\"\nparser = buildparser(kd, fstsrc, target)\nbasename(parser.sfstpath)","category":"page"},{"location":"stemtypes/nouns/nounstems/#Noun-stems","page":"Nouns","title":"Noun stems","text":"","category":"section"},{"location":"stemtypes/nouns/nounstems/","page":"Nouns","title":"Nouns","text":"The automatically generated paradigms on this page illustrate nouns accent belonging to various stem types, and with various patterns of persistent accent.  They belong to the dataset defined in the datasets/core-infl directory of the Kanones github repository.","category":"page"},{"location":"stemtypes/nouns/nounstems/","page":"Nouns","title":"Nouns","text":"In the tables below, the nouns are labelled with the Kanones stem type they belong to.","category":"page"},{"location":"stemtypes/nouns/nounstems/#First-declension-types","page":"Nouns","title":"First declension types","text":"","category":"section"},{"location":"stemtypes/nouns/nounstems/","page":"Nouns","title":"Nouns","text":"Literary Greek orthography:","category":"page"},{"location":"stemtypes/nouns/nounstems/","page":"Nouns","title":"Nouns","text":"using Kanones, CitableParserBuilder, Markdown\n\nβουλη = LexemeUrn(\"lsj.n20600\")\nγνωμη = LexemeUrn(\"lsj.n22502\")\nθεραπαινα = LexemeUrn(\"lsj.n48369\")\nοικια = LexemeUrn(\"lsj.n72287\")\nnouns = [γνωμη, βουλη,οικια,θεραπαινα]\n\nrepo = pwd() |> dirname |> dirname  |> dirname |> dirname\nds = dataset(repo * \"/datasets/core-infl/\")\nMarkdown.parse(mddeclension(nouns, ds))","category":"page"},{"location":"stemtypes/nouns/nounstems/","page":"Nouns","title":"Nouns","text":"Attic orthography:","category":"page"},{"location":"stemtypes/nouns/nounstems/","page":"Nouns","title":"Nouns","text":"using Kanones, CitableParserBuilder, Markdown, AtticGreek\nbole = LexemeUrn(\"lsj.n20600\")\nrepo = pwd() |> dirname |> dirname  |> dirname |> dirname\nattic = dataset([repo * \"/datasets/attic/\"]; ortho=atticGreek())\nMarkdown.parse(mddeclension([bole], attic))","category":"page"},{"location":"stemtypes/nouns/nounstems/#Second-declension-types","page":"Nouns","title":"Second declension types","text":"","category":"section"},{"location":"stemtypes/nouns/nounstems/","page":"Nouns","title":"Nouns","text":"Literary Greek orthography:","category":"page"},{"location":"stemtypes/nouns/nounstems/","page":"Nouns","title":"Nouns","text":"repo = pwd() |> dirname |> dirname  |> dirname |> dirname\nusing Kanones, CitableParserBuilder, Markdown\nkd = dataset(repo * \"/datasets/core-infl/\")\n\nανθρωπος = LexemeUrn(\"lsj.n8909\")\nδωρον = LexemeUrn(\"lsj.n29828\")\n\nnouns = [ανθρωπος,δωρον ]\nMarkdown.parse(mddeclension(nouns, kd))","category":"page"},{"location":"stemtypes/nouns/nounstems/","page":"Nouns","title":"Nouns","text":"Attic Greek orthography:","category":"page"},{"location":"stemtypes/nouns/nounstems/","page":"Nouns","title":"Nouns","text":"repo = pwd() |> dirname |> dirname  |> dirname |> dirname\nusing Kanones, CitableParserBuilder, Markdown, AtticGreek\nattic = dataset(repo * \"/datasets/attic/\"; ortho=atticGreek())\n\nανθρωπος = LexemeUrn(\"lsj.n8909\")\n\nnouns = [ανθρωπος]\nMarkdown.parse(mddeclension(nouns, attic))","category":"page"},{"location":"stemtypes/nouns/nounstems/#Third-declension-types","page":"Nouns","title":"Third declension types","text":"","category":"section"},{"location":"stemtypes/nouns/nounstems/","page":"Nouns","title":"Nouns","text":"Literary Greek orthography:","category":"page"},{"location":"stemtypes/nouns/nounstems/","page":"Nouns","title":"Nouns","text":"repo = pwd() |> dirname |> dirname  |> dirname |> dirname\nusing Kanones, CitableParserBuilder, Markdown\nkd = dataset(repo * \"/datasets/core-infl/\")\n\nπολις = LexemeUrn(\"lsj.n84494\")\n\nnouns = [πολις]\n\nMarkdown.parse(mddeclension(nouns, kd))","category":"page"},{"location":"stemtypes/#Illustrative-paradigms","page":"Contents","title":"Illustrative paradigms","text":"","category":"section"},{"location":"stemtypes/","page":"Contents","title":"Contents","text":"The following pages illustrate various stem types Kanones defines for each analytical type.  They include automatically generated declensions and synopses for each stem type in the dataset defined in the datasets/core-infl subdirectory of the Kanones github repository.","category":"page"},{"location":"stemtypes/","page":"Contents","title":"Contents","text":"Add table of contents for paradigms here.","category":"page"},{"location":"prereqs/#Prerequisites","page":"Prerequisites","title":"Prerequisites","text":"","category":"section"},{"location":"prereqs/","page":"Prerequisites","title":"Prerequisites","text":"a POSIX-like environment with sh, echo and make\nthe Stuttgart FST toolkit","category":"page"},{"location":"fst/#Internals-of-building-and-using-a-finite-state-transducer","page":"FST","title":"Internals of building and using a finite state transducer","text":"","category":"section"},{"location":"fst/","page":"FST","title":"FST","text":"note: Note\nIn order to use Kanones.jl, it is not necessary to understand the internal logic that the FST follows in parsing morphology","category":"page"},{"location":"fst/","page":"FST","title":"FST","text":"The final parsing transducer is actually created by a chain of smaller transducers. In broad outline, they do the following:","category":"page"},{"location":"fst/","page":"FST","title":"FST","text":"combine all lexical entries (\"stems\") with all inflectional rules (that is, generate the cross product of stems and rules)\npass to a transducer that accepts only pairings of stems and rules belonging to the same stemtype (defined in symbols/stemtypes.fst)\ncategorize all symbols as either \"surface\" symbols, or \"analytical\" symbols, and allow only one category to pass through","category":"page"},{"location":"fst/","page":"FST","title":"FST","text":"The transducers that do this work are organized in the following directories:","category":"page"},{"location":"fst/#FST-symbols","page":"FST","title":"FST symbols","text":"","category":"section"},{"location":"fst/","page":"FST","title":"FST","text":"A finite state transducer transforms symbols between a generated, or surface, form and an analysis.","category":"page"},{"location":"fst/","page":"FST","title":"FST","text":"The vocabulary of symbols  is defined in the file symbols.fst located in the root directory of the build. This file in turn uses include statements to draw together symbol definitions from five files in the adjacent symbols directory. Together, these define the complete set of symbols recognized by the FST, so any transducer has access to the full symbol set by including symbols.fst.","category":"page"},{"location":"fst/#Organization-of-definitions-in-the-symbols-directory","page":"FST","title":"Organization of definitions in the symbols directory","text":"","category":"section"},{"location":"fst/","page":"FST","title":"FST","text":"Within the symbols directory, definitions are organized as follows:","category":"page"},{"location":"fst/","page":"FST","title":"FST","text":"alphabet.fst: defines the symbols used to encode text strings in this orthography.  This is generated automatically from an implementation of GreekOrthograpy.\nmarkup.fst: special symbols for separating stem from inflectional component in the morphological database, and marking the beginning and ends of URN values in the data.\nmorphsymbols.fst: defines symbols for analytical values (such as “gender”, “case” and “number” for nouns).\nphonology.fst: defines all legal symbols in the FST other than the morphological categories defined in stemtypes.fst\nstemtypes.fst: defines symbols in the FST for morphological categories for stems.","category":"page"},{"location":"bg/#Background","page":"Background","title":"Background","text":"","category":"section"},{"location":"bg/","page":"Background","title":"Background","text":"morphological analysis is most frequently achieved with FSTs\nmorphology of accented Greek is not reversible with FSTs due to complex interactions of morphology and mutable accent\nKanones uses the \"analysis by synthesis\" algorithm first developed by Kosman and Smith in the early 1980s.","category":"page"},{"location":"bg/#Analysis-by-synthesis","page":"Background","title":"Analysis by synthesis","text":"","category":"section"},{"location":"bg/","page":"Background","title":"Background","text":"morphology of Greek can be analyzed with FSTs if accent is not considered\naccent can be algorithmically added to a lexical token if morphology is already known","category":"page"},{"location":"bg/","page":"Background","title":"Background","text":"So to analyze a token:","category":"page"},{"location":"bg/","page":"Background","title":"Background","text":"generate a normalized accented form\ndrop accents added from enclitics\nconvert barytone to oxytone\ngenerate a form with all accents stripped\nanalyze the accent-free form using a FST.  The result is an Array of 0 or more analyses that are considered hypotheses.\nFor each hypothesis, add the appropriate accent to the unaccented string, and compare to the normalized accented form created in step 1.  If they match, the hypothetical analysis is valid.","category":"page"},{"location":"stemtypes/nouns/irregulars/#Irregular-nouns","page":"Irregular nouns","title":"Irregular nouns","text":"","category":"section"},{"location":"stemtypes/nouns/irregulars/","page":"Irregular nouns","title":"Irregular nouns","text":"Irregular nouns do not have a stem type.  Irregular noun forms can be individually cataloged in the irregular-stems/nouns directory of your dataset's files.","category":"page"},{"location":"analyses/#Work-with-morphological-analyses","page":"Working with analytical data","title":"Work with morphological analyses","text":"","category":"section"},{"location":"analyses/","page":"Working with analytical data","title":"Working with analytical data","text":"Kanones.jl offers functions for working with analyses.\nKanones.jl supports converting the output of an SFST  parser built with Kanones.jl to an object model.  ","category":"page"},{"location":"analyses/#An-example","page":"Working with analytical data","title":"An example","text":"","category":"section"},{"location":"analyses/#Parse-a-token","page":"Working with analytical data","title":"Parse a token","text":"","category":"section"},{"location":"analyses/","page":"Working with analytical data","title":"Working with analytical data","text":"using Kanones\nusing Kanones.FstBuilder\nusing CitableParserBuilder\nreporoot = pwd() |> dirname |> dirname |> dirname\ntarget = reporoot * \"/parsers/demo/\"\ndatadirectory = reporoot * \"/datasets/core-infl/\"\nkd = dataset([datadirectory])\nfstsrc = reporoot *  \"/fst/\"\nparser = buildparser(kd, fstsrc, target)","category":"page"},{"location":"analyses/","page":"Working with analytical data","title":"Working with analytical data","text":"Build a parser, as we did in the example on the previous page.","category":"page"},{"location":"analyses/","page":"Working with analytical data","title":"Working with analytical data","text":"basename(parser.sfstpath)","category":"page"},{"location":"analyses/","page":"Working with analytical data","title":"Working with analytical data","text":"Parsing a token returns a (possibly empty) Vector of analyses.","category":"page"},{"location":"analyses/","page":"Working with analytical data","title":"Working with analytical data","text":"analyses = parsetoken(\"κελεύσει\", parser)","category":"page"},{"location":"analyses/#Analyses","page":"Working with analytical data","title":"Analyses","text":"","category":"section"},{"location":"analyses/","page":"Working with analytical data","title":"Working with analytical data","text":"Each analysis has a form of the token stripped of accents, plus four objects with special types of Cite2URNs","category":"page"},{"location":"analyses/","page":"Working with analytical data","title":"Working with analytical data","text":"a1 = analyses[1]\na1.token","category":"page"},{"location":"analyses/","page":"Working with analytical data","title":"Working with analytical data","text":"The two most important URNs are the lexeme and the form.","category":"page"},{"location":"analyses/","page":"Working with analytical data","title":"Working with analytical data","text":"a1.lexeme","category":"page"},{"location":"analyses/","page":"Working with analytical data","title":"Working with analytical data","text":"a1.form","category":"page"},{"location":"analyses/","page":"Working with analytical data","title":"Working with analytical data","text":"You can use the labelform function to get a human-readable label for a form.","category":"page"},{"location":"analyses/","page":"Working with analytical data","title":"Working with analytical data","text":"Kanones.labelform(a1.form.objectid)","category":"page"},{"location":"analyses/#Working-with-analyses","page":"Working with analytical data","title":"Working with analyses","text":"","category":"section"},{"location":"analyses/","page":"Working with analytical data","title":"Working with analytical data","text":"Get a morphform for the analysis.  You can give morphform just about anything you can think of (Cite2Urn, FormUrn, string, for example).  Here, we'll just get it directly from the Analysis.","category":"page"},{"location":"analyses/","page":"Working with analytical data","title":"Working with analytical data","text":"mform = Kanones.morphform(a1)","category":"page"},{"location":"analyses/","page":"Working with analytical data","title":"Working with analytical data","text":"We can check the type of form, and get appropriate information for that type.","category":"page"},{"location":"analyses/","page":"Working with analytical data","title":"Working with analytical data","text":"tensedata = if isa(mform, FiniteVerbForm)\n        (mform.vtense)\nelse\n        nothing\nend\ntensedata","category":"page"},{"location":"analyses/","page":"Working with analytical data","title":"Working with analytical data","text":"analyses2 = parsetoken(\"δωρα\", parser)\na2 = analyses2[1]\nform2 = Kanones.morphform(a2)\ngenderdata = if isa(form2, NounForm)\n        (form2.ngender)\nelse\n        nothing\nend\ngenderdata","category":"page"},{"location":"analyses/#URNs","page":"Working with analytical data","title":"URNs","text":"","category":"section"},{"location":"analyses/","page":"Working with analytical data","title":"Working with analytical data","text":"FormUrns and LexemeUrns are both subtypes of the CitableParserBuilder's AbbreviatedUrn type. You can expand any AbbreviatedUrn using a diction mapping collection abbreviations to full Cite2Urns for the collection.","category":"page"},{"location":"analyses/","page":"Working with analytical data","title":"Working with analytical data","text":"using CitableParserBuilder\nregistry = Dict(\n        \"morphforms\" => \"urn:cite2:kanones:morphforms.v1:\"\n)\nexpanded = expand(a1.form, registry)","category":"page"},{"location":"analyses/","page":"Working with analytical data","title":"Working with analytical data","text":"","category":"page"},{"location":"datasets/#Managing-Kanones-datasets","page":"Managing Kanones datasets","title":"Managing Kanones datasets","text":"","category":"section"},{"location":"datasets/","page":"Managing Kanones datasets","title":"Managing Kanones datasets","text":"You manage rules and stems in delimited-text files\nKanones has a required directory structure for data files","category":"page"},{"location":"datasets/","page":"Managing Kanones datasets","title":"Managing Kanones datasets","text":"See the reference section for information on predefined stem types.","category":"page"},{"location":"datasets/#Directory-organization","page":"Managing Kanones datasets","title":"Directory organization","text":"","category":"section"},{"location":"datasets/","page":"Managing Kanones datasets","title":"Managing Kanones datasets","text":"Kanones checks for .cex files in the following subdirectories of a data source:","category":"page"},{"location":"datasets/","page":"Managing Kanones datasets","title":"Managing Kanones datasets","text":"├── irregular-stems\n│   ├── adjectives\n│   ├── adverbs\n│   ├── finiteverbs\n│   ├── infinitives\n│   ├── nouns\n│   ├── participles\n│   └── pronouns\n├── rules-tables\n│   ├── adjectives\n│   ├── adverbs\n│   ├── finiteverbs\n│   ├── infinitives\n│   ├── nouns\n│   ├── participles\n│   └── uninflected\n├── stems-tables\n│   ├── adjectives\n│   ├── nouns\n│   ├── uninflected\n│   ├── verbs-compound\n│   └── verbs-simplex\n└── urnregistry\n    ├── lexemes\n    ├── rules\n    └── stems","category":"page"},{"location":"datasets/#Loading-a-dataset","page":"Managing Kanones datasets","title":"Loading a dataset","text":"","category":"section"},{"location":"datasets/","page":"Managing Kanones datasets","title":"Managing Kanones datasets","text":"Use the dataset function to create a Kanones.Dataset.","category":"page"},{"location":"datasets/","page":"Managing Kanones datasets","title":"Managing Kanones datasets","text":"Pass in a list of full paths to one or more directories laid out according to Kanones conventions, and optionally an orthography.  The default orthogrpahy is LiteraryGreekOthography.","category":"page"},{"location":"datasets/","page":"Managing Kanones datasets","title":"Managing Kanones datasets","text":"repo = pwd() |> dirname |> dirname  |> dirname\nsrc1 = repo * \"/datasets/core-infl/\"\nsrc2 = repo * \"/datasets/core-vocab/\"\nusing Kanones","category":"page"},{"location":"datasets/","page":"Managing Kanones datasets","title":"Managing Kanones datasets","text":"datasrcs = [src1, src2]\nkdata = dataset(datasrcs)","category":"page"},{"location":"datasets/#Working-with-stems-and-rules","page":"Managing Kanones datasets","title":"Working with stems and rules","text":"","category":"section"},{"location":"datasets/","page":"Managing Kanones datasets","title":"Managing Kanones datasets","text":"rulesarray\nstemsarray","category":"page"},{"location":"stemtypes/uninflected/#Uninflected-forms","page":"Uninflected types","title":"Uninflected forms","text":"","category":"section"},{"location":"stemtypes/uninflected/","page":"Uninflected types","title":"Uninflected types","text":"have a \"part of speech\" type","category":"page"},{"location":"apis/apis/#Julia-language-API-documentation","page":"Julia API documentation","title":"Julia language API documentation","text":"","category":"section"},{"location":"apis/apis/","page":"Julia API documentation","title":"Julia API documentation","text":"Pages = [\"apis.md\"]\nDepth = 3","category":"page"},{"location":"apis/apis/#Morphology","page":"Julia API documentation","title":"Morphology","text":"","category":"section"},{"location":"apis/apis/#Structures","page":"Julia API documentation","title":"Structures","text":"","category":"section"},{"location":"apis/apis/","page":"Julia API documentation","title":"Julia API documentation","text":"MorphologicalForm\nKanones.UninflectedForm\nKanones.NounForm\nKanones.FiniteVerbForm","category":"page"},{"location":"apis/apis/#Kanones.MorphologicalForm","page":"Julia API documentation","title":"Kanones.MorphologicalForm","text":"Abstract type of a morphological form in Kanones.\n\n\n\n\n\n","category":"type"},{"location":"apis/apis/#Kanones.UninflectedForm","page":"Julia API documentation","title":"Kanones.UninflectedForm","text":"Uninflected forms have a single property: the \"part of speech\".\n\n\n\n\n\n","category":"type"},{"location":"apis/apis/#Kanones.NounForm","page":"Julia API documentation","title":"Kanones.NounForm","text":"Nouns have gender, case and number.\n\n\n\n\n\n","category":"type"},{"location":"apis/apis/#Kanones.FiniteVerbForm","page":"Julia API documentation","title":"Kanones.FiniteVerbForm","text":"Finite verbs have person, number, tense, mood and voice.\n\n\n\n\n\n","category":"type"},{"location":"apis/apis/#Functions","page":"Julia API documentation","title":"Functions","text":"","category":"section"},{"location":"apis/apis/","page":"Julia API documentation","title":"Julia API documentation","text":"Kanones.urn\nKanones.cex\nKanones.morphform\nKanones.abbrurn\nKanones.formscex\nKanones.formurn\nKanones.pospairs\nKanones.uninflectedpairs\nKanones.casepairs\nKanones.personpairs\nKanones.numberpairs\nKanones.voicepairs\nKanones.tensepairs\nKanones.moodpairs\nKanones.valuedict\nKanones.labeldict\nKanones.labelform\nKanones.nounform\nKanones.nounscex\nKanones.uninflectedform\n\nKanones.uninflectedcex\nKanones.finiteverbform\n","category":"page"},{"location":"apis/apis/#CitableBase.urn","page":"Julia API documentation","title":"CitableBase.urn","text":"Delegate to specific functions based on  type's citable trait value.\n\nurn(x)\n\n\n\n\n\n\nIt is an error to invoke the urn function on material that is not citable.\n\nurn(_, x)\n\n\n\n\n\n\nCitable text content should implement cex.\n\nurn(_, txt)\n\n\n\n\n\n\nCitable content should implement cex.\n\nurn(_, obj)\n\n\n\n\n\n\nURN identifyiing psg.\n\nurn(psg)\n\n\nRequired function for Citable abstraction.\n\n\n\n\n\nURN identifyiing doc.\n\nurn(doc)\n\n\nRequired function for Citable abstraction.\n\n\n\n\n\nImplement urn function required by Citable interface  for CatalogedText.\n\nurn(cataloged)\n\n\n\n\n\n\nUnique identifier for AnalyzedToken (required for Citable interface).\n\nurn(at)\n\n\n\n\n\n\nConvert a MorphologicalForm to a Cite2Urn.\n\nurn(mf)\n\n\nAll subclasses of MorphologicalForm should implement this specifically for their subclass.\n\n\n\n\n\nCompose URN for an UninflectedForm.\n\nurn(uform)\n\n\n\n\n\n\nCompose a Cite2Urn for a NounForm.\n\nurn(noun)\n\n\n\n\n\n\nCompose a Cite2Urn for an AdjectiveForm.\n\nurn(adj)\n\n\n\n\n\n\nCompose URN for a FiniteVerbForm.\n\nurn(verb)\n\n\n\n\n\n\n","category":"function"},{"location":"apis/apis/#CitableBase.cex","page":"Julia API documentation","title":"CitableBase.cex","text":"Delegate to specific functions based on  type's citable trait value.\n\ncex(x)\ncex(x, delim)\n\n\n\n\n\n\nIt is an error to invoke the cex function on material that is not citable.\n\ncex(_, x, delim)\n\n\n\n\n\n\nCitable text content should implement cex.\n\ncex(_, txt, delim)\n\n\n\n\n\n\nCitable content should implement cex.\n\ncex(_, obj, delim)\n\n\n\n\n\n\nFormat a CitablePassage as a delimited-text string.\n\ncex(psg)\ncex(psg, delim)\n\n\nRequired function for Citable abstraction.\n\n\n\n\n\nFormat a CitableDocument as a CEX ctsdata block.\n\ncex(doc)\ncex(doc, delim)\n\n\nRequired function for Citable abstraction.\n\n\n\n\n\nCompose a delimited-text string for a corpus.\n\ncex(c; delimiter)\n\n\n\n\n\n\nImplement cex function required by Citable interface  for CatalogedText.\n\ncex(cataloged)\ncex(cataloged, delimiter)\n\n\n\n\n\n\nSerialize an AnalyzedToken as delimited text (required for Citable interface).\n\ncex(at)\ncex(at, delim)\n\n\nUses abbreviated URNs.   These can be expanded to full CITE2 URNs when read back with a URN registry, or the delimited function can be used with a URN registry to write full CITE2 URNs.\n\n\n\n\n\nConvert a MorphologicalForm form to a delimited-text string. \n\ncex(mf, delim)\n\n\nAll subclasses of MorphologicalForm should implement this specifically for their subclass.\n\n\n\n\n\nCompose URN for an UninflectedForm.\n\ncex(uform)\n\n\n\n\n\n\nCompose CEX representation for a NounForm.\n\ncex(noun)\ncex(noun, delim)\n\n\n\n\n\n\nCompose CEX representation for a AdjectiveForm.\n\ncex(adj)\ncex(adj, delim)\n\n\n\n\n\n\nCompose CEX representation for a FiniteVerbForm.\n\ncex(verb)\n\n\n\n\n\n\n","category":"function"},{"location":"apis/apis/#Kanones.morphform","page":"Julia API documentation","title":"Kanones.morphform","text":"Create a MorphologicalForm from a Cite2Urn value.\n\nmorphform(urn)\n\n\n\n\n\n\nCreate a MorphologicalForm from a FormUrn.\n\nmorphform(u)\n\n\n\n\n\n\nCreate a MorphologicalForm from an Analysis.\n\nmorphform(a)\n\n\n\n\n\n\nCreate a MorphologicalForm from an string value.\n\nmorphform(code)\n\n\n\n\n\n\n","category":"function"},{"location":"apis/apis/#Kanones.abbrurn","page":"Julia API documentation","title":"Kanones.abbrurn","text":"Generic function to convert form information in a Rule to a RuleUrn.\n\nabbrurn(rule)\n\n\n\n\n\n\nCompose an abbreviated URN for a form from a NounRule.\n\nabbrurn(rule)\n\n\n\n\n\n\nCompose an abbreviated URN for a form from a AdjectiveRule.\n\nabbrurn(rule)\n\n\n\n\n\n\n","category":"function"},{"location":"apis/apis/#Kanones.formscex","page":"Julia API documentation","title":"Kanones.formscex","text":"Compose CEX representation of CITE colletion of all recognized forms.\n\nformscex()\n\n\nCurrently, includes only:\n\nunanalyzed forms\nuninflected forms\nnoun forms\ninflected verb forms\n\n\n\n\n\n","category":"function"},{"location":"apis/apis/#Kanones.formurn","page":"Julia API documentation","title":"Kanones.formurn","text":"Generic function to convert form information in a MorphologicalForm to a FormUrn.\n\nformurn(rule)\n\n\n\n\n\n\nCompose a FormUrn for an UninflectedForm.\n\nformurn(uninflected)\n\n\n\n\n\n\nCompose a FormUrn for a NounForm.\n\nformurn(nounform)\n\n\n\n\n\n\nCompose a FormUrn for a PronounForm.\n\nformurn(pronounform)\n\n\n\n\n\n\nCompose a FormUrn for an AdjectiveForm.\n\nformurn(adj)\n\n\n\n\n\n\nCompose a FormUrn for a FiniteVerbForm.\n\nformurn(verbform)\n\n\n\n\n\n\nCompose a FormUrn for an InfinitiveForm.\n\nformurn(infinitive)\n\n\n\n\n\n\nCompose a FormUrn for an InfinitiveForm.\n\nformurn(ptcpl)\n\n\n\n\n\n\nCompose a FormUrn for an InfinitiveForm.\n\nformurn(vadj)\n\n\n\n\n\n\n","category":"function"},{"location":"apis/apis/#Kanones.pospairs","page":"Julia API documentation","title":"Kanones.pospairs","text":"Constants for analytical types (\"parts of speech\").\n\n\n\n\n\n","category":"constant"},{"location":"apis/apis/#Kanones.uninflectedpairs","page":"Julia API documentation","title":"Kanones.uninflectedpairs","text":"Constants for uninflected type of uninflected form.\n\n\n\n\n\n","category":"constant"},{"location":"apis/apis/#Kanones.casepairs","page":"Julia API documentation","title":"Kanones.casepairs","text":"Constants for substantive case.\n\n\n\n\n\n","category":"constant"},{"location":"apis/apis/#Kanones.personpairs","page":"Julia API documentation","title":"Kanones.personpairs","text":"Constants for persons.\n\n\n\n\n\n","category":"constant"},{"location":"apis/apis/#Kanones.numberpairs","page":"Julia API documentation","title":"Kanones.numberpairs","text":"Constants for number.\n\n\n\n\n\n","category":"constant"},{"location":"apis/apis/#Kanones.voicepairs","page":"Julia API documentation","title":"Kanones.voicepairs","text":"Constants for voice.\n\n\n\n\n\n","category":"constant"},{"location":"apis/apis/#Kanones.tensepairs","page":"Julia API documentation","title":"Kanones.tensepairs","text":"Constants for tense.\n\n\n\n\n\n","category":"constant"},{"location":"apis/apis/#Kanones.moodpairs","page":"Julia API documentation","title":"Kanones.moodpairs","text":"Constants for mood.\n\n\n\n\n\n","category":"constant"},{"location":"apis/apis/#Kanones.valuedict","page":"Julia API documentation","title":"Kanones.valuedict","text":"Create a dictionary keyed by the value of a label-value pair.\n\nvaluedict(prs)\n\n\n\n\n\n\n","category":"function"},{"location":"apis/apis/#Kanones.labeldict","page":"Julia API documentation","title":"Kanones.labeldict","text":"Create a dictionary keyed by the label of a label-value pair.\n\nlabeldict(prs)\n\n\n\n\n\n\n","category":"function"},{"location":"apis/apis/#Kanones.labelform","page":"Julia API documentation","title":"Kanones.labelform","text":"Compose a human-readable lable for a morphological form identifier.\n\nlabelform(s)\n\n\n\n\n\n\nCompose a human-readable label for a FormUrn.\n\nlabelform(furn)\n\n\n\n\n\n\nCompose a human-readable label for a FormUrn.\n\nlabelform(furn)\n\n\n\n\n\n\n","category":"function"},{"location":"apis/apis/#Kanones.nounform","page":"Julia API documentation","title":"Kanones.nounform","text":"Create a NounForm from a string value.\n\nnounform(code)\n\n\n\n\n\n\nCreate a NounForm from a Cite2Urn.\n\nnounform(urn)\n\n\n\n\n\n\nCreate a NounForm from a FormUrn.\n\nnounform(f)\n\n\n\n\n\n\nCreate a NounForm from an Analysis.\n\nnounform(a)\n\n\n\n\n\n\n","category":"function"},{"location":"apis/apis/#Kanones.nounscex","page":"Julia API documentation","title":"Kanones.nounscex","text":"Compose CEX representation of URNs and labels for noun forms.\n\nnounscex()\n\n\n\n\n\n\n","category":"function"},{"location":"apis/apis/#Kanones.uninflectedform","page":"Julia API documentation","title":"Kanones.uninflectedform","text":"Create UninflectedForm from a Cite2Urn.\n\nuninflectedform(urn)\n\n\n\n\n\n\nCreate UninflectedForm from a FormUrn.\n\nuninflectedform(u)\n\n\n\n\n\n\nCreate UninflectedForm from a string value.\n\nuninflectedform(codeString)\n\n\n\n\n\n\nCreate UninflectedForm from a Char.\n\nuninflectedform(ch)\n\n\n\n\n\n\nCreate UninflectedForm from an Int.\n\nuninflectedform(code)\n\n\n\n\n\n\nCreate UninflectedForm from an Analysis.\n\nuninflectedform(a)\n\n\n\n\n\n\n","category":"function"},{"location":"apis/apis/#Kanones.uninflectedcex","page":"Julia API documentation","title":"Kanones.uninflectedcex","text":"Compose CEX representation of URNs and labels for uninflected forms.\n\nuninflectedcex()\n\n\n\n\n\n\n","category":"function"},{"location":"apis/apis/#Kanones.finiteverbform","page":"Julia API documentation","title":"Kanones.finiteverbform","text":"Create a FiniteVerbForm from a string value.\n\nfiniteverbform(code)\n\n\n\n\n\n\nCreate a FiniteVerbForm from a Cite2URN.\n\nfiniteverbform(urn)\n\n\n\n\n\n\nCreate a FiniteVerbForm from a FormUrn.\n\nfiniteverbform(f)\n\n\n\n\n\n\nCreate a FiniteVerbForm from an Analysis.\n\nfiniteverbform(a)\n\n\n\n\n\n\n","category":"function"},{"location":"apis/apis/#Datasets","page":"Julia API documentation","title":"Datasets","text":"","category":"section"},{"location":"apis/apis/#Structures-2","page":"Julia API documentation","title":"Structures","text":"","category":"section"},{"location":"apis/apis/","page":"Julia API documentation","title":"Julia API documentation","text":"Kanones.Dataset\nKanones.KanonesIO\nKanones.NounParser\nKanones.NounStem\nKanones.NounRule\nKanones.UninflectedParser\nKanones.UninflectedStem\nKanones.UninflectedRule\nKanones.VerbParser","category":"page"},{"location":"apis/apis/#Kanones.Dataset","page":"Julia API documentation","title":"Kanones.Dataset","text":"A Kanones dataset in a local file system.  \n\nMembers\n\ndirs is a list of full paths to the root directory of one or more datasets.  \n\nTheir subdirectory organization must follow Kanones' specifications.\n\northography is an implementation of the GreekOrthography interface\n\n\n\n\n\n","category":"type"},{"location":"apis/apis/#Kanones.KanonesIO","page":"Julia API documentation","title":"Kanones.KanonesIO","text":"Implementations of this type can read delimited and write fst.\n\n\n\n\n\n","category":"type"},{"location":"apis/apis/#Kanones.NounParser","page":"Julia API documentation","title":"Kanones.NounParser","text":"KanonesIO type for reading and writing data for noun forms.\n\n\n\n\n\n","category":"type"},{"location":"apis/apis/#Kanones.NounStem","page":"Julia API documentation","title":"Kanones.NounStem","text":"A record for a single noun stem.\n\n\n\n\n\n","category":"type"},{"location":"apis/apis/#Kanones.NounRule","page":"Julia API documentation","title":"Kanones.NounRule","text":"Inflectional rule for uninflected lexical items.\n\n\n\n\n\n","category":"type"},{"location":"apis/apis/#Kanones.UninflectedParser","page":"Julia API documentation","title":"Kanones.UninflectedParser","text":"KanonesIO type for reading and writing stem for uninflected forms.\n\n\n\n\n\n","category":"type"},{"location":"apis/apis/#Kanones.UninflectedStem","page":"Julia API documentation","title":"Kanones.UninflectedStem","text":"A record for a single uninflected stem.\n\n\n\n\n\n","category":"type"},{"location":"apis/apis/#Kanones.UninflectedRule","page":"Julia API documentation","title":"Kanones.UninflectedRule","text":"Inflectional rule for uninflected lexical items.\n\n\n\n\n\n","category":"type"},{"location":"apis/apis/#Kanones.VerbParser","page":"Julia API documentation","title":"Kanones.VerbParser","text":"KanonesIO type for reading and writing data for finite verb form.\n\n\n\n\n\n","category":"type"},{"location":"apis/apis/#Functions-2","page":"Julia API documentation","title":"Functions","text":"","category":"section"},{"location":"apis/apis/","page":"Julia API documentation","title":"Julia API documentation","text":"Exported: ","category":"page"},{"location":"apis/apis/","page":"Julia API documentation","title":"Julia API documentation","text":"dataset\nrulesarray\nstemsarray","category":"page"},{"location":"apis/apis/#Kanones.dataset","page":"Julia API documentation","title":"Kanones.dataset","text":"Create a Kanones.Dataset from a single data source.\n\ndataset(dir; ortho)\n\n\nArguments\n\ndir Full path to a directory with Kanones data.\northo An instance of a GreekOrthography; defaults to LiteraryGreekOrthography.\n\n\n\n\n\nCreate a Kanones.Dataset from one or more data sources.\n\ndataset(srclist; ortho)\n\n\nArguments\n\nsrclist List of full paths to a directory with Kanones data.\northo An instance of a GreekOrthography; defaults to LiteraryGreekOrthography.\n\n\n\n\n\n","category":"function"},{"location":"apis/apis/#Kanones.rulesarray","page":"Julia API documentation","title":"Kanones.rulesarray","text":"Read all rules data from a list of directories into an array of Rules.\n\nrulesarray(kd)\n\n\n\n\n\n\nRead all rules data from a Kanones.Dataset into an array of Rules.\n\nrulesarray(dirlist)\n\n\n\n\n\n\n","category":"function"},{"location":"apis/apis/#Kanones.stemsarray","page":"Julia API documentation","title":"Kanones.stemsarray","text":"Read all stem data from a list of directories into an array of Stems.\n\nstemsarray(kd)\n\n\n\n\n\n\nRead all stem data from a Kanones.Dataset into an array of Stems.\n\nstemsarray(dirlist)\n\n\n\n\n\n\n","category":"function"},{"location":"apis/apis/","page":"Julia API documentation","title":"Julia API documentation","text":"Internals:","category":"page"},{"location":"apis/apis/","page":"Julia API documentation","title":"Julia API documentation","text":"Kanones.readstemrow\nKanones.readrulerow\nKanones.id\nKanones.lexeme\nKanones.abbrformurn","category":"page"},{"location":"apis/apis/#Kanones.readstemrow","page":"Julia API documentation","title":"Kanones.readstemrow","text":"Implementation of reading one row of a stems table for uninflected tokens.\n\nreadstemrow(usp, delimited)\nreadstemrow(usp, delimited, delimiter)\n\n\n\n\n\n\nRead one row of a stems table for noun tokens and create a NounStem.\n\nreadstemrow(usp, delimited)\nreadstemrow(usp, delimited, delimiter)\n\n\n\n\n\n\nRead one row of a stems table for noun tokens and create a NounStem.\n\nreadstemrow(usp, delimited)\nreadstemrow(usp, delimited, delimiter)\n\n\n\n\n\n\nRead one row of a stems table for noun tokens and create a NounStem.\n\nreadstemrow(usp, delimited)\nreadstemrow(usp, delimited, delimiter)\n\n\n\n\n\n\nImplementation of reading one row of a stems table for finite verbs.\n\nreadstemrow(usp, delimited)\nreadstemrow(usp, delimited, delimiter)\n\n\n\n\n\n\nRead one row of a stems table for adjective tokens and create an AdjectiveStem.\n\nreadstemrow(usp, delimited)\nreadstemrow(usp, delimited, delimiter)\n\n\n\n\n\n\n","category":"function"},{"location":"apis/apis/#Kanones.readrulerow","page":"Julia API documentation","title":"Kanones.readrulerow","text":"Implementation of reading one row of a rules table for uninflected tokens.\n\nreadrulerow(usp, delimited)\nreadrulerow(usp, delimited, delimiter)\n\n\n\n\n\n\nImplementation of reading one row of a rules table for uninflected tokens.\n\nreadrulerow(usp, delimited)\nreadrulerow(usp, delimited, delimiter)\n\n\n\n\n\n\nRead one row of a stems table for noun tokens and create a NounStem.\n\nreadrulerow(usp, delimited)\nreadrulerow(usp, delimited, delimiter)\n\n\n\n\n\n\nImplementation of reading one row of a rules table for irregular tokens.\n\nreadrulerow(ruleparser, delimited)\nreadrulerow(ruleparser, delimited, delimiter)\n\n\n\n\n\n\nRead one row of a rules table for verb tokens and create a FiniteVerbRule\n\nreadrulerow(usp, delimited)\nreadrulerow(usp, delimited, delimiter)\n\n\n\n\n\n\nRead one row of a rules table for infinitives and create an InfinitiveRule.\n\nreadrulerow(usp, delimited)\nreadrulerow(usp, delimited, delimiter)\n\n\n\n\n\n\nRead one row of a rules table for infinitives and create an InfinitiveRule.\n\nreadrulerow(usp, delimited)\nreadrulerow(usp, delimited, delimiter)\n\n\n\n\n\n\nRead one row of a rules table for infinitives and create an InfinitiveRule.\n\nreadrulerow(usp, delimited)\nreadrulerow(usp, delimited, delimiter)\n\n\n\n\n\n\nImplementation of reading one row of a rules table for uninflected tokens.\n\nreadrulerow(usp, delimited)\nreadrulerow(usp, delimited, delimiter)\n\n\n\n\n\n\n","category":"function"},{"location":"apis/apis/#Kanones.id","page":"Julia API documentation","title":"Kanones.id","text":"Identify identifier URN for an UninflectedStem.\n\nid(uninfl)\n\n\n\n\n\n\nIdentify identifier URN for an UninflectedRule.\n\nid(uninfl)\n\n\n\n\n\n\nIdentify identifier URN for a NounStem.\n\nid(n)\n\n\n\n\n\n\nIdentify identifier URN for a NounRule.\n\nid(n)\n\n\n\n\n\n\n","category":"function"},{"location":"apis/apis/#Kanones.lexeme","page":"Julia API documentation","title":"Kanones.lexeme","text":"Identify lexeme URN for an UninflectedStem.\n\nlexeme(uninfl)\n\n\n\n\n\n\nIdentify lexeme URN for a NounStem.\n\nlexeme(n)\n\n\n\n\n\n\n","category":"function"},{"location":"apis/apis/#Kanones.abbrformurn","page":"Julia API documentation","title":"Kanones.abbrformurn","text":"Compose FormUrn for an irregular noun stem.\n\nabbrformurn(irregstem)\n\n\nFor irregulars, all form information is in the stem entry, so we need  a function to create form urns directory from this.\n\n\n\n\n\n","category":"function"},{"location":"apis/apis/#Analysis","page":"Julia API documentation","title":"Analysis","text":"","category":"section"},{"location":"apis/apis/#Exported-functions","page":"Julia API documentation","title":"Exported functions","text":"","category":"section"},{"location":"apis/apis/","page":"Julia API documentation","title":"Julia API documentation","text":"parsetoken\nparsewordlist\nparsedocument\nparsecorpus","category":"page"},{"location":"apis/apis/#CitableParserBuilder.parsetoken","page":"Julia API documentation","title":"CitableParserBuilder.parsetoken","text":"Delegate to specific functions based on type's citable trait value.\n\nparsetoken(s, x; data)\n\n\n\n\n\n\nIt is an error to invoke the parsetoken using types that are not a parser.\n\nparsetoken(, s, x; data)\n\n\n\n\n\n\nCitable parsers must implement parsetoken.\n\nparsetoken(, s, x; data)\n\n\n\n\n\n\nParse String s by looking it up in a given dictionary.\n\n\n\n\n\nParse a single token to an array of Analysis or nothing.\n\nparsetoken(tkn, parser; data)\n\n\n\n\n\n\n","category":"function"},{"location":"apis/apis/#CitableParserBuilder.parsewordlist","page":"Julia API documentation","title":"CitableParserBuilder.parsewordlist","text":"Parse a list of tokens with a CitableParser.\n\nparsewordlist(vocablist, p; data, countinterval)\n\n\nReturns a Dict mapping strings to a (possibly empty) vector of Analysis objects.\n\n\n\n\n\nOverride implementation in CitableParser.\n\nparsewordlist(vocablist, parser; data, countinterval)\n\n\nReturns a Dict mapping strings to a (possibly empty) vector of Analysis objects.\n\n\n\n\n\n","category":"function"},{"location":"apis/apis/#CitableParserBuilder.parsedocument","page":"Julia API documentation","title":"CitableParserBuilder.parsedocument","text":"Use a CitableParser to parse a CitableTextCorpus with each citable node containing containg a single token.\n\nparsedocument(doc, p; data)\n\n\nShould return a list of AnalyzedTokens.\n\n\n\n\n\nOverride implementation in CitableParserBuilder.\n\nparsedocument(doc, p; data, countinterval)\n\n\nShould return a list of AnalyzedTokens.\n\n\n\n\n\n","category":"function"},{"location":"apis/apis/#CitableParserBuilder.parsecorpus","page":"Julia API documentation","title":"CitableParserBuilder.parsecorpus","text":"Use a CitableParser to parse a CitableTextCorpus with each citable node containing containg a single token.\n\nparsecorpus(c, p; data, countinterval)\n\n\nShould return a list of AnalyzedTokens.\n\n\n\n\n\nOverride implementation in CitableParserBuilder.\n\nparsecorpus(c, p; data, countinterval)\n\n\nShould return a list of AnalyzedTokens.\n\n\n\n\n\n","category":"function"},{"location":"apis/apis/#Functions-used-internally-in-parsing-via-a-FST","page":"Julia API documentation","title":"Functions used internally in parsing via a FST","text":"","category":"section"},{"location":"apis/apis/","page":"Julia API documentation","title":"Julia API documentation","text":"Kanones.stemsforlex\nKanones.fstinflpath\nKanones.echopath\nKanones.functionforcategory\nKanones.parsefst\nKanones.applyparser","category":"page"},{"location":"apis/apis/#Kanones.stemsforlex","page":"Julia API documentation","title":"Kanones.stemsforlex","text":"Find stems for a given lexeme.\n\nstemsforlex(lex, stems)\n\n\n\n\n\n\n","category":"function"},{"location":"apis/apis/#Kanones.fstinflpath","page":"Julia API documentation","title":"Kanones.fstinflpath","text":"Find full path to fst-inflon your system.\n\nfstinflpath()\n\n\n\n\n\n\n","category":"function"},{"location":"apis/apis/#Kanones.echopath","page":"Julia API documentation","title":"Kanones.echopath","text":"Find full path to echoon your system.\n\nechopath()\n\n\n\n\n\n\n","category":"function"},{"location":"apis/apis/#Kanones.functionforcategory","page":"Julia API documentation","title":"Kanones.functionforcategory","text":"Dictionary of functions to use with each analytical type to determine a FormUrn from the FST description of form.\n\nfunctionforcategory()\n\n\n\n\n\n\n","category":"function"},{"location":"apis/apis/#Kanones.parsefst","page":"Julia API documentation","title":"Kanones.parsefst","text":"Parse a string of FST output for a single token to a list of Analysis objects.\n\nparsefst(fststring)\n\n\n\n\n\n\n","category":"function"},{"location":"apis/apis/#Kanones.applyparser","page":"Julia API documentation","title":"Kanones.applyparser","text":"Apply a parser to a token using fst-infl. Suppress standard error since this generates show-stopping IO demands if routed to terminal.\n\napplyparser(tkn, parser)\n\n\n\n\n\n\nUses the external fst-infl command to apply parser to a list of vocabulary, and returns the string output of fst-infl.\n\napplyparser(vocablist, parser)\n\n\n\n\n\n\n","category":"function"},{"location":"apis/apis/#Generation","page":"Julia API documentation","title":"Generation","text":"","category":"section"},{"location":"apis/apis/","page":"Julia API documentation","title":"Julia API documentation","text":"Exported:","category":"page"},{"location":"apis/apis/","page":"Julia API documentation","title":"Julia API documentation","text":"generate","category":"page"},{"location":"apis/apis/#Kanones.generate","page":"Julia API documentation","title":"Kanones.generate","text":"Generate a string for the form of a given Analysis using a given dataset.\n\ngenerate(analysis, kd)\n\n\n\n\n\n\nGenerate a string for a given form and lexeme using a given dataset.\n\ngenerate(form, lex, kd)\n\n\n\n\n\n\n","category":"function"},{"location":"apis/apis/","page":"Julia API documentation","title":"Julia API documentation","text":"Internal:","category":"page"},{"location":"apis/apis/","page":"Julia API documentation","title":"Julia API documentation","text":"Kanones.generateuninflected\nKanones.generatenoun","category":"page"},{"location":"apis/apis/#Kanones.generateuninflected","page":"Julia API documentation","title":"Kanones.generateuninflected","text":"Generate vector of possible strings for correctly accented form of uninflected token identified by analysis.\n\ngenerateuninflected(analysis, kd; ortho)\n\n\nBecause uninflected  forms record a full, accented string in their stem record, all we have to do is find matching stem records, and extract their form members.\n\n\n\n\n\n","category":"function"},{"location":"apis/apis/#Kanones.generatenoun","page":"Julia API documentation","title":"Kanones.generatenoun","text":"Generate vector of possible strings for correctly accented form of a noun form identified by lexeme.\n\ngeneratenoun(form, lex, kd)\n\n\n\n\n\n\nGenerate vector of possible strings for correctly accented form of a noun form identified by analysis.\n\ngeneratenoun(analysis, kd)\n\n\n\n\n\n\n","category":"function"},{"location":"apis/apis/#Kanones.FstBuilder","page":"Julia API documentation","title":"Kanones.FstBuilder","text":"","category":"section"},{"location":"apis/apis/","page":"Julia API documentation","title":"Julia API documentation","text":"The functions of the FstBuilder submodule compose expressions in SFST-PL, the language of the Stuttgart FST toolkit.","category":"page"},{"location":"apis/apis/","page":"Julia API documentation","title":"Julia API documentation","text":"Kanones.FstBuilder.buildparser\nKanones.FstBuilder.buildlexicon\nKanones.FstBuilder.buildinflection\nKanones.FstBuilder.buildfinalfst\nKanones.FstBuilder.buildmakefile\nKanones.FstBuilder.compilefst\nKanones.FstBuilder.buildacceptor\nKanones.FstBuilder.uninflsquasher\nKanones.FstBuilder.nounsquasher\nKanones.FstBuilder.installalphabet\nKanones.FstBuilder.installsymbols\nKanones.FstBuilder.symbolsfst\nKanones.FstBuilder.fstok\nKanones.FstBuilder.cmdok\nKanones.FstBuilder.fst\nKanones.FstBuilder.addsmooth\nKanones.FstBuilder.addrough\nKanones.FstBuilder.greekfromfst\nKanones.FstBuilder.fstgreek","category":"page"},{"location":"apis/apis/#Kanones.FstBuilder.buildparser","page":"Julia API documentation","title":"Kanones.FstBuilder.buildparser","text":"Read data from src and fstdir and compile a SFST parser in target.\n\nbuildparser(src, fstdir, target)\nbuildparser(src, fstdir, target, label; force)\n\n\nReturns the path to the compiled binary greek.a which can then be used as an argument to the parsetoken function.\n\n\n\n\n\n","category":"function"},{"location":"apis/apis/#Kanones.FstBuilder.buildlexicon","page":"Julia API documentation","title":"Kanones.FstBuilder.buildlexicon","text":"Read all stem data and compose lexicon.fst.\n\nbuildlexicon(src, target)\n\n\nArguments\n\nsrc is a Kanones.Dataset.  \ntarget is the full path to the desination file lexicon.fst.\n\n\n\n\n\n","category":"function"},{"location":"apis/apis/#Kanones.FstBuilder.buildinflection","page":"Julia API documentation","title":"Kanones.FstBuilder.buildinflection","text":"Read all rules data and compose inflection.fst.\n\nbuildinflection(src, target)\n\n\nArguments\n\nsrc is a Kanones.Dataset.  \ntarget is the full path to the desination file inflection.fst.\n\n\n\n\n\n","category":"function"},{"location":"apis/apis/#Kanones.FstBuilder.buildfinalfst","page":"Julia API documentation","title":"Kanones.FstBuilder.buildfinalfst","text":"Compose top-level transducer greek.fst.\n\nbuildfinalfst(target)\n\n\nArguments\n\ntarget is the full path to the desination file greek.fst.\n\n\n\n\n\n","category":"function"},{"location":"apis/apis/#Kanones.FstBuilder.buildmakefile","page":"Julia API documentation","title":"Kanones.FstBuilder.buildmakefile","text":"Compose makefile.\n\nbuildmakefile(target)\n\n\nArguments\n\nsrc is a Kanones.Dataset.  \ntarget is the full path to the desination file makefile.\n\n\n\n\n\n","category":"function"},{"location":"apis/apis/#Kanones.FstBuilder.compilefst","page":"Julia API documentation","title":"Kanones.FstBuilder.compilefst","text":"Compile binary parser with make.\n\ncompilefst(target)\n\n\nArguments\n\ntarget is a directory with a makefile.\n\n\n\n\n\n","category":"function"},{"location":"apis/apis/#Kanones.FstBuilder.buildacceptor","page":"Julia API documentation","title":"Kanones.FstBuilder.buildacceptor","text":"Compose acceptor.fst and write to file target.\n\nbuildacceptor(target)\n\n\n\n\n\n\n","category":"function"},{"location":"apis/apis/#Kanones.FstBuilder.uninflsquasher","page":"Julia API documentation","title":"Kanones.FstBuilder.uninflsquasher","text":"Compose transducer for filtering uninflected forms.\n\nuninflsquasher()\n\n\n\n\n\n\n","category":"function"},{"location":"apis/apis/#Kanones.FstBuilder.nounsquasher","page":"Julia API documentation","title":"Kanones.FstBuilder.nounsquasher","text":"Compose transducer for filtering nouns.\n\nnounsquasher()\n\n\n\n\n\n\n","category":"function"},{"location":"apis/apis/#Kanones.FstBuilder.installalphabet","page":"Julia API documentation","title":"Kanones.FstBuilder.installalphabet","text":"Install alphabet.fst required to be part of an individual project.\n\ninstallalphabet(src, target)\n\n\n\n\n\n\n","category":"function"},{"location":"apis/apis/#Kanones.FstBuilder.installsymbols","page":"Julia API documentation","title":"Kanones.FstBuilder.installsymbols","text":"Install symbols FST from generic FST source applying to many projects.\n\ninstallsymbols(src, target)\n\n\n\n\n\n\n","category":"function"},{"location":"apis/apis/#Kanones.FstBuilder.symbolsfst","page":"Julia API documentation","title":"Kanones.FstBuilder.symbolsfst","text":"Compose content for top-level symbols.fst file.\n\nsymbolsfst(dir)\n\n\n\n\n\n\n","category":"function"},{"location":"apis/apis/#Kanones.FstBuilder.fstok","page":"Julia API documentation","title":"Kanones.FstBuilder.fstok","text":"True if all necessary SFST components are installed.\n\nfstok()\n\n\n\n\n\n\n","category":"function"},{"location":"apis/apis/#Kanones.FstBuilder.cmdok","page":"Julia API documentation","title":"Kanones.FstBuilder.cmdok","text":"True if executable cmd is found.\n\ncmdok(cmd)\n\n\n\n\n\n\n","category":"function"},{"location":"apis/apis/#Kanones.FstBuilder.fst","page":"Julia API documentation","title":"Kanones.FstBuilder.fst","text":"Compose FST representation of a single UniflectedStem.\n\nfst(stem, ortho)\n\n\n\n\n\n\nCompose FST representation of a single UninflectedRule.\n\nfst(rule, ortho)\n\n\n\n\n\n\nCompose FST representation of a single NounStem.\n\nfst(stem, ortho)\n\n\n\n\n\n\nCompose FST representation of a single NounRule.\n\nfst(rule, ortho)\n\n\n\n\n\n\nCompose FST representation of a single PronounStem.\n\nfst(stem, ortho)\n\n\n\n\n\n\nCompose FST representation of a single PronounRule.\n\nfst(rule, ortho)\n\n\n\n\n\n\nCompose FST representation of a single AdjectiveStem.\n\nfst(stem, ortho)\n\n\n\n\n\n\nCompose FST representation of a single AdjectiveRule.\n\nfst(rule, ortho)\n\n\n\n\n\n\nCompose FST representation of a single IrregularNounStem.\n\nfst(stem, ortho)\n\n\n\n\n\n\nCompose FST representation of a single IrregularVerbStem.\n\nfst(stem, ortho)\n\n\n\n\n\n\nCompose FST representation of a single IrregularVerbStem.\n\nfst(stem, ortho)\n\n\n\n\n\n\nCompose FST representation of a single UninflectedRule.\n\nfst(rule, ortho)\n\n\n\n\n\n\nCompose FST representation of a single VerbStem.\n\nfst(stem, ortho)\n\n\n\n\n\n\nCompose FST representation of a single VerbRule.\n\nfst(rule, ortho)\n\n\n\n\n\n\nCompose FST representation of a single InfinitiveRule.\n\nfst(rule, ortho)\n\n\n\n\n\n\nCompose FST representation of a single ParticipleRule.\n\nfst(rule, ortho)\n\n\n\n\n\n\nCompose FST representation of a single InfinitiveRule.\n\nfst(rule, ortho)\n\n\n\n\n\n\n","category":"function"},{"location":"apis/apis/#Kanones.FstBuilder.addsmooth","page":"Julia API documentation","title":"Kanones.FstBuilder.addsmooth","text":"Add smooth breathing to a vowel.\n\naddsmooth(vowel)\n\n\n\n\n\n\n","category":"function"},{"location":"apis/apis/#Kanones.FstBuilder.addrough","page":"Julia API documentation","title":"Kanones.FstBuilder.addrough","text":"Add rough breathing to a vowel.\n\naddrough(vowel)\n\n\n\n\n\n\n","category":"function"},{"location":"apis/apis/#Kanones.FstBuilder.greekfromfst","page":"Julia API documentation","title":"Kanones.FstBuilder.greekfromfst","text":"Convert FST string to Unicode representation of Greek.\n\ngreekfromfst(fst)\n\n\n\n\n\n\n","category":"function"},{"location":"apis/apis/#Kanones.FstBuilder.fstgreek","page":"Julia API documentation","title":"Kanones.FstBuilder.fstgreek","text":"Convert Greek string s to FST representation.\n\nfstgreek(s)\nfstgreek(s, ortho)\n\n\n\n\n\n\n","category":"function"},{"location":"#Kanones.jl","page":"Home","title":"Kanones.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Build corpus-specific parsers for ancient Greek texts in a specified orthography.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Kanones.jl lets you build morphological parsers for ancient Greek.  It works with three central concepts: ","category":"page"},{"location":"","page":"Home","title":"Home","text":"An explicitly defined orthography.\nA morphological dataset (stems and inflectional rules) managed in plain-text tables.\nAnalyses recorded with URNs identifying lexemes, forms and the entries in the dataset leading the analysis.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Because Kanones.jl cleanly separates orthography and morphology, you can compile parsers for standard literary Greek, epichoric Greek alphabets, or Greek with manuscript symbols, for example.  Because it manages stems and inflectional rules in plain-text tables, an editor or Greek student can easily tailor a parser to a specific corpus by adding or deleting entries.  Because analyses are expressed with URNs, Kanones.jl's analytical tools can profile a corpus, and even compare lexical and morphological features across corpora in different orthographies. ","category":"page"},{"location":"#More-backgound","page":"Home","title":"More backgound","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Read more about the rationale and approach to parsing a historical language in \"Morphological Analysis of Historical Languages\" (Bulletin of the Institute for Classical Studies 59-2, 2016, 89-102).","category":"page"},{"location":"#Shortest-possible-example","page":"Home","title":"Shortest possible example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"note: Note\nThe example builds a parser using a sample dataset included in the Kanones.jl git repository.  See the user's manual for a fuller explanation .","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Kanones\nusing Kanones.FstBuilder\nusing CitableParserBuilder\nreporoot = pwd() |> dirname |> dirname\ntarget = reporoot * \"/parsers/demo/\"","category":"page"},{"location":"#Orthography-and-morphological-dataset","page":"Home","title":"Orthography and morphological dataset","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Load morphological data and definition of the dataset's orthography into a Kanones.Dataset structure.","category":"page"},{"location":"","page":"Home","title":"Home","text":"datadirectory = reporoot * \"/datasets/core-infl/\"\nkd = dataset([datadirectory])","category":"page"},{"location":"#Compile-a-parser","page":"Home","title":"Compile a parser","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"identify a directory with the core FST files from the Kanones.jl repository\nidentify a target directory where you want to compile a parser\ncompile a parser. The binary FST parser will be named greek.a","category":"page"},{"location":"","page":"Home","title":"Home","text":"fstsrc = reporoot *  \"/fst/\"\nparser = buildparser(kd, fstsrc, target)\nbasename(parser.sfstpath)","category":"page"}]
}
